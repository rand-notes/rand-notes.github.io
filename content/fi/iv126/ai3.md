---
date: 2021-10-14
url: fi/iv126/3
title: lec 03
---


# Population-based Metaheuristics

- Genetic Algorithms
- Evolution Strategies
- Genetic Programming
- Ant Colony Optimization
- Particle Swarm Optimization
- Bee Colony
- Artificial Immune Systems
- Estimation of Distribution Algorithms

general algo:

```python
t = 0
while not end_condition:
 generate_popul(P_t) # generate new population
 P_t+1 = choose_new_popul()
 t += 1
```

Basic division:

**Algorithms using evolution**  
Solution in population is choosed and reproduced with operators (mutation and crossovering).

e.g. genetics algorithms, evolution strategies

**Algorithms using memory (blackboard)**  
solution in population is participating on construction of memory which is used to create new individuals.

e.g. pheromone matrix (ACO), probability learning model (EDA)


# Generating Initial Population

**Random generating**

**Sequential Diversification**
Solution is gradually generating with maximum difference

e.g. **Simple Sequential Inhibition (SSI)** process - every next solution generating so distance from all previous solutions will be at least \\( \delta \\); computationally intensive 

**Paralel Diversification**

Solutions generating independently in parallel with the effort to achieve maximum difference of the solution in the population. Might be more difficult than solving the origin problem.


**Heuristic Initialization**

individual solutions generated by arbitrary heuristic algorithms (e.g. local search); danger of small difference in population solutions.



# Ending Conditions

## Static Procedure

End of searching is known ahead. e.g. fixed number of iterations; CPU resource limit; max number of evaluation of the objective function.


## Adaptive Procedure

End of searching is not known ahead. e.g. fixed number of iterations without improving; computing enough qualite solution; small difference between population solutions.



# Common Concepts of Evolution Algorithms

## Representation

**population** - set of solutions(~20 to 100)  
**chromosome/individual** - encodedd solution  
**gen** - decision variable in within solution  
**alleles** - alely - possible values of the decision variable  


## Fitness

used term for objective function

## Selection Strategies

Selection Strategies of parents for creating new population

## Reproduction Strategies

crossovers and mutations: operations to create new individuals

## Replacement Strategies

selection of individuals to a new population

# Genetic Algorithms

- First representation was binary, now extended by another.
- Typically used cross operator over two solutions.
- For improved diversification is used mutation 
- Fixed probability of mutation p_m and cross p_c
- Replacement is usually generational: parents are systematically replaced by childs.


# Evolution Strategies

- Often used for continuos optimalizations, real valued vectors
- Cross used rarely
- Typically replacement by best individuals (elitism)

\\( (1 + 1) \\) ES - basic version, 1 parent replaced by 1 offspring  
\\( (\mu + \lambda) \\) ES - repeat \\( \lambda \\) times (random selection of parent, generate offspring), sort \\( \mu \\) parents a \\( \lambda \\) offsprings and replace by the best  
\\( (1 + 1) \\) ES - for a new population it is selected only among \\( \lambda \\) offspring 


# Roulette Wheel Selection

- Most used selection strategy.
- \\(f_i\\) suitability of the individual i in the population 
- probability of selection individual is given by \\( p_i = f_i / \sum^n_{j=1}(f_j) \\)

Analogy: Roulette Wheel with parts for every individual in population. Size of roulette wheel part for individual is equal to \\( p_i \\)

Problems: too big effort to choose quality individuals -> premature convergence


# Stochaistic Universal Sampling

- Improved Roulette Wheel Selection
- Probabilistic universal sampling
- Roulette wheel has \\( \mu \\) universally placed pointers
- One turn of wheel choose \\( \mu \\) individuals. 

{{<image src="/images/iv126/roulette.png" alt="roulette" position="center">}}

# Tournament Selection

- random selection of k individuals
- tournament: out of these k individuals is chosen only one.
- to choose \mu individuals, we applied tournament \mu times.

# Rank-based Selection

- for every individuals is computed rank, which is used to choosing individuals.
- rank can e.g. scaling lineary with dependence on the effort to select the best individual.
- rank can be used to compute probability and applied same as roulette wheel.


# Mutation

operator of mutation change individuals in population and cause its small change.
Probability of gene mutation \\( p_m \in [0.001, 0.01] \\)
e.g. initialization p_m to 1/k where k is number of genes (decision variables), i.e. in average 1 mutated variable.


## Mutation in Binary Representation

Flip values in binary variable

## Mutation in Discrete Representation

Replacement element value by another in aplhabet

## Mutation in Permutation

Insert, Replacement, Inversion of values.

e.g. with permutaiton neighborhood for planning problems.



# Crossovering

Binary (sometimes n-ary) operator
Goal is to inherit properties of parents by offspring.
Probability of crossovering parents \\( p_c \in [0, 1] \\) usually \\( p_c \in [0.45, 0.95] \\)

## Linear Representation

### 1-point crossover
according to selected position k in offsprings are swapped values of two parents.

{{<image src="/images/iv126/1pointcrossover.png" alt="crossover" position="center">}}

### 2-point (and n-point) crossover

it's selected n positions and performed swapping positions.

{{<image src="/images/iv126/2pointcrossover.png" alt="crossover" position="center">}}


### Uniform Crossover

Individuals combined regardless on size of segments. Every gene of offspring is randomly selected from parent. Every parent contribute to offspring uniformly.


{{<image src="/images/iv126/uniformcrossover.png" alt="crossover" position="center">}}


## Permutation Representation

Crossovering is more difficult, individuals cannot be easily combined, because every allele (value) must be in individual only once. There are used various forms of mapping.

### Order Crossover, OX

Two random points of crossover. Then values from parent 1 are copied on same positions in offspring. Then we are start from second point and we copy elements from parent 2 that wasn't selected from
parent 1.


{{<image src="/images/iv126/ordercrossover.png" alt="crossover" position="center">}}


/todo example


# Strategy Replacement


We choose next population between parents and offsprings.

## Extreme Replacement Strategy

not very often used.

**Generational Replacement**

Offsprings replace systematically whole population of parents. We lose also the best individuals.

**Steady-state Replacement**

Only one offspring will be generated, which replace e.g. the words individual in population.

**Replacement of Fixed Number of Individuals**

There are choosed \\( \lambda \\) individuals for replacement at size of population \\( \mu \\)

\\(1 \lt \lambda \lt \mu \\)


**Elitistic model**

Best from both parents and offsprings are choosed. May be too quick convergence.


# Swarm Intelligence

Algorithms inspired by group behaviour of species such as ants, bees, termites, birds etc.
Origin in the social behavior of these species in search of food.


Common Characteristics of these algorithms:
- Individuals are simpler non-sofisticated agents.
- Individuals cooperate indirectly via medium.


## Ant Colony Optimization, ACO

Idea:
 - Ant colony able to find the shortest path between two points.
 - Ants are leaving a chemical track (pheromone).
 - Pheromones are leading ants to goal.
 - Pheromones are gradually evaporating.

Algorithm:
 - Initialization of pheromones
 - Iteration: Construction of solution by ant, updating the pheromones
 
### Pheromone Information

\\(\tau\\) typically as matrix/vector of values containing the pheromone track.  
e.g. matrix as graph representation containing the pheromone on the edges.


### Pheromone Evaporating

\\(\tau_{ij} = (1 - \rho) t_{ij} \\) realized for every i, j
\\(p \in [0, 1]\\)

### Pheromone Reinforcing

**online update**: \\( \tau_{i,j} updated at every step \\)

**onlined delayed update**: \\(\tau\\) updated after complete solution found by one ant.  
e.g. the more solutions, the more pheromone reinforcing

**offline update** \\(\tau\\) updated after solution found by all ants. Most popular approach.  
e.g. pheromone update by quality (by the best or n best) solutions

/todo example















