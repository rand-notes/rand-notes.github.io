<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="Measurement of processing/compute time Optimization impossible without knowledge what to optimize We need to know data about program run Processing/run time of the whole program: time command Processing/run time of individual program components: profiling Run time comparison: benchmarking time command User time: Processor time consumed by user’s processes System time: Processor time consumed by the kernel services Elapsed time: Total run time (wall clock time) Profiling Attempt to get timing information about program parts Emphasis on dynamic (run time) behavior: static analysis is a part of software engineering Profiling shows a result of an interaction between program and the computing system it runs on Time spent in individual blocks Time spent in individual commands Number of repetition of blocks/commands Primary interest on procedures Profile: graph X axis: individual procedures Y axis: run time Basic principles Uses software tools for collection of data needed for the profile construction Usually some operating system support access to information available to kernel only Examples of usual profiling tools: gprof, oprofile, valgrind, pin Profile collected during the run time – dynamic profile Performance Engineering is the name of the profile data analysis Types of data collected Call graph at the procedures and functions level Call graph at the basis blocks level Memory performance Events related to the architecture, e."><meta name=keywords content><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://rand-notes.github.io/pa039/04/><title>notes 04 :: idk</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/main.7209ab6422eb371a6b685a56274cc88eff3db604665c3bdb698389c0585d4211.css><meta itemprop=name content="notes 04"><meta itemprop=description content="Measurement of processing/compute time Optimization impossible without knowledge what to optimize We need to know data about program run Processing/run time of the whole program: time command Processing/run time of individual program components: profiling Run time comparison: benchmarking time command User time: Processor time consumed by user’s processes System time: Processor time consumed by the kernel services Elapsed time: Total run time (wall clock time) Profiling Attempt to get timing information about program parts Emphasis on dynamic (run time) behavior: static analysis is a part of software engineering Profiling shows a result of an interaction between program and the computing system it runs on Time spent in individual blocks Time spent in individual commands Number of repetition of blocks/commands Primary interest on procedures Profile: graph X axis: individual procedures Y axis: run time Basic principles Uses software tools for collection of data needed for the profile construction Usually some operating system support access to information available to kernel only Examples of usual profiling tools: gprof, oprofile, valgrind, pin Profile collected during the run time – dynamic profile Performance Engineering is the name of the profile data analysis Types of data collected Call graph at the procedures and functions level Call graph at the basis blocks level Memory performance Events related to the architecture, e."><meta itemprop=datePublished content="2022-05-05T00:00:00+00:00"><meta itemprop=dateModified content="2022-05-05T00:00:00+00:00"><meta itemprop=wordCount content="646"><meta itemprop=image content="https://rand-notes.github.io"><meta itemprop=keywords content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rand-notes.github.io"><meta name=twitter:title content="notes 04"><meta name=twitter:description content="Measurement of processing/compute time Optimization impossible without knowledge what to optimize We need to know data about program run Processing/run time of the whole program: time command Processing/run time of individual program components: profiling Run time comparison: benchmarking time command User time: Processor time consumed by user’s processes System time: Processor time consumed by the kernel services Elapsed time: Total run time (wall clock time) Profiling Attempt to get timing information about program parts Emphasis on dynamic (run time) behavior: static analysis is a part of software engineering Profiling shows a result of an interaction between program and the computing system it runs on Time spent in individual blocks Time spent in individual commands Number of repetition of blocks/commands Primary interest on procedures Profile: graph X axis: individual procedures Y axis: run time Basic principles Uses software tools for collection of data needed for the profile construction Usually some operating system support access to information available to kernel only Examples of usual profiling tools: gprof, oprofile, valgrind, pin Profile collected during the run time – dynamic profile Performance Engineering is the name of the profile data analysis Types of data collected Call graph at the procedures and functions level Call graph at the basis blocks level Memory performance Events related to the architecture, e."><meta property="og:title" content="notes 04"><meta property="og:description" content="Measurement of processing/compute time Optimization impossible without knowledge what to optimize We need to know data about program run Processing/run time of the whole program: time command Processing/run time of individual program components: profiling Run time comparison: benchmarking time command User time: Processor time consumed by user’s processes System time: Processor time consumed by the kernel services Elapsed time: Total run time (wall clock time) Profiling Attempt to get timing information about program parts Emphasis on dynamic (run time) behavior: static analysis is a part of software engineering Profiling shows a result of an interaction between program and the computing system it runs on Time spent in individual blocks Time spent in individual commands Number of repetition of blocks/commands Primary interest on procedures Profile: graph X axis: individual procedures Y axis: run time Basic principles Uses software tools for collection of data needed for the profile construction Usually some operating system support access to information available to kernel only Examples of usual profiling tools: gprof, oprofile, valgrind, pin Profile collected during the run time – dynamic profile Performance Engineering is the name of the profile data analysis Types of data collected Call graph at the procedures and functions level Call graph at the basis blocks level Memory performance Events related to the architecture, e."><meta property="og:type" content="article"><meta property="og:url" content="https://rand-notes.github.io/pa039/04/"><meta property="og:image" content="https://rand-notes.github.io"><meta property="article:section" content="fi"><meta property="article:published_time" content="2022-05-05T00:00:00+00:00"><meta property="article:modified_time" content="2022-05-05T00:00:00+00:00"><meta property="og:site_name" content="idk"><meta property="article:published_time" content="2022-05-05 00:00:00 +0000 UTC"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo>title</div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/posts>notes</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class="theme-toggle not-selectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=https://rand-notes.github.io/pa039/04/>notes 04</a></h2><div class=post-content><h1 id=measurement-of-processingcompute-time>Measurement of processing/compute time</h1><ul><li>Optimization impossible without knowledge what to optimize</li><li>We need to know data about program run</li><li>Processing/run time of the whole program: time command</li><li>Processing/run time of individual program components: profiling</li><li>Run time comparison: benchmarking</li></ul><h2 id=time-command>time command</h2><ul><li>User time: Processor time consumed by user’s processes</li><li>System time: Processor time consumed by the kernel services</li><li>Elapsed time: Total run time (wall clock time)</li></ul><h1 id=profiling>Profiling</h1><ul><li>Attempt to get timing information about program parts</li><li>Emphasis on dynamic (run time) behavior: static analysis is a part of software engineering</li><li>Profiling shows a result of an interaction between program and the computing system it runs on</li><li>Time spent in individual blocks</li><li>Time spent in individual commands</li><li>Number of repetition of blocks/commands</li><li>Primary interest on procedures</li><li>Profile: graph</li><li>X axis: individual procedures</li><li>Y axis: run time</li></ul><h1 id=basic-principles>Basic principles</h1><ul><li>Uses software tools for collection of data needed for the profile construction</li><li>Usually some operating system support</li><li>access to information available to kernel only</li><li>Examples of usual profiling tools: gprof, oprofile, valgrind, pin</li><li>Profile collected during the run time – <strong>dynamic profile</strong></li><li><strong>Performance Engineering</strong> is the name of the profile data analysis</li></ul><h1 id=types-of-data-collected>Types of data collected</h1><ul><li>Call graph at the procedures and functions level</li><li>Call graph at the basis blocks level</li><li>Memory performance</li><li>Events related to the architecture, e.g. incorrect branch predictions, exemptions, cache performance (hit/miss), &mldr;</li><li>Performance counters values</li></ul><h1 id=profile-types>Profile types</h1><ul><li>Sharp profile</li><li>Peaks related to the dominating blocks/procedures</li><li>Numerical applications, technical computing with matrices etc</li><li>“Easily” optimizable</li><li>Flat profile</li><li>Program spends its run time uniformly in all blocks/procedures</li><li>Usually databases, information systems, operating systems</li><li>Difficult to optimize</li><li>Amdahl rule is valid here, too</li></ul><h1 id=profilers>Profilers</h1><ul><li>Tools for profile construction</li><li>Naturally possible also “manually”</li><li>Procedure oriented: gprof</li><li>Block (line) oriented: pixie, lprof</li></ul><h1 id=profilers-use>Profilers’ use</h1><p>Two phases:</p><ul><li>Instrumented program execution (with or without a need for re-compiling)</li><li>Profile Analysis Report
Access to the source code</li><li>Knowledge of program structure</li></ul><p>It is possible to profile a program even without an access to the source code</p><h1 id=procedure-oriented-profilers>Procedure oriented profilers</h1><ul><li>Typical representative: gprof</li><li>Instrumentation<ul><li>Re-compiling of the program</li><li>Usually available through a special compiler key (</li></ul></li><li>Run time</li><li>Instrumented program creates a compute (processing) trail, file e.g. gmon.out</li><li>Report construction</li><li>gprof run over the previously generated gmon.out file</li></ul><h1 id=measurement-precision>Measurement precision</h1><p>Time measurement</p><ul><li>Absolute time of a procedure entry/exit: Nested vs Short procedures</li><li>Instruction counter value read in uniform intervals: Sampling interval influences the precision of the measurement</li></ul><h1 id=block-oriented-profilers>Block oriented profilers</h1><ul><li>Provides information about basic block’s processing</li><li>Number of executions per command (program line)</li><li>Number of processor cycles spent in each command</li></ul><h1 id=benchmarking>Benchmarking</h1><ul><li>Attempt to compare performance of whole systems</li><li>Jointly hardware and software</li><li>No “silver bullet” solution</li><li>Basic approaches</li><li>Professional benchmarks: Comparability, vendor independence</li><li>“Private” benchmarks: Specific requirements (deeper knowledge what you need)</li></ul><h1 id=mysterious-mips-and-mflops>Mysterious MIPS and MFLOPS</h1><ul><li>Comparison based on number of instructions per second</li><li>MIPS – million instructions per second</li><li>MFLOPS – million floating point instructions per second</li><li>Problems</li><li>Which instructions</li><li>Which order</li><li>Artificial, not adequate</li></ul><h1 id=fixed-point-benchmarks>Fixed point benchmarks</h1><ul><li>VAX MIPS</li><li>Dhrystones</li></ul><h1 id=floating-point-benchmarks>Floating point benchmarks</h1><ul><li>Whetstone (artificial mix, scalar)</li><li>Linpack (daxpy, vectorization)</li></ul><h1 id=spec-benchmarks>SPEC benchmarks</h1><ul><li>Independent organization: Standard Performance Evaluation Corporation</li><li>Standardized benchmarks for different architectures</li><li>Based on the so called kernel codes</li><li>Part or a whole existing program</li><li>Available in the source code</li></ul><h1 id=spec-groups>SPEC groups</h1><ul><li>Open Systems Group (OSG)</li><li>High Performance Group (HPG)</li><li>Graphics Performance Characterization Group (GPC)</li></ul><h1 id=transaction-benchmarks>Transaction benchmarks</h1><p>Database performance</p><ul><li>TPC-A</li><li>TPC-B</li><li>TPC-C</li></ul><h1 id=network-benchmarks>Network benchmarks</h1><ul><li>End to end measurements</li><li>Be aware, what you are actually measuring in the network: Not so difficult if within a parallel computer interconnect</li></ul><h1 id=own-benchmarks>Own benchmarks</h1><ul><li>Concrete (specific) requirements</li><li>Important parameters</li><li>What/how long to test</li><li>memory requirements</li><li>Benchmark types</li><li>single stream</li><li>throughput</li></ul><h1 id=checks>Checks</h1><ul><li>Mandatory part of any benchmarking activity</li><li>Are we actually measuring what we want to?</li><li>Potential influencers:</li><li>Used complier optimization</li><li>Memory size</li><li>Other process served by the operating system</li><li>What must be controlled explicitly</li><li>CPU time and wall clock time</li><li>Results!</li><li>Comparison with “a known” standard</li></ul></div></article><hr><div class=post-info></div></main></div><footer class=footer></footer><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script></div><script type=text/javascript src=/bundle.min.77414ca1a0d130043c129098d97cecf433ce369d23de8eaa91f5111f432729db1257c49a33b38203d4be241ef53dafecd99a1d2c350b75316b55a0bb6a2e150b.js integrity="sha512-d0FMoaDRMAQ8EpCY2Xzs9DPONp0j3o6qkfURH0MnKdsSV8SaM7OCA9S+JB71Pa/s2ZodLDULdTFrVaC7ai4VCw=="></script></body></html>