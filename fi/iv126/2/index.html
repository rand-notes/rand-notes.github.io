<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="Neighborhoods Definition: Function of neighborhood N is mapping \( N: S \rightarrow 2^S \), which assign every solution s from Z, set of solutions \( N(S) \subset S \)
Effective Algorithms for Searching in Very Large Neighborhoods space size: polynom of higher order of magnitude (n &amp;gt; 2)
main problem is indentification of improving neighborhoods or best neighbor without enumeration of whole neighborhood.
Ejection Chain e.g. Capacitated Vehicle Routing Problem"><meta name=keywords content><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://rand-notes.github.io/fi/iv126/2/><title>lec 2 :: idk</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/main.7209ab6422eb371a6b685a56274cc88eff3db604665c3bdb698389c0585d4211.css><meta itemprop=name content="lec 2"><meta itemprop=description content="Neighborhoods Definition: Function of neighborhood N is mapping \( N: S \rightarrow 2^S \), which assign every solution s from Z, set of solutions \( N(S) \subset S \)
Effective Algorithms for Searching in Very Large Neighborhoods space size: polynom of higher order of magnitude (n > 2)
main problem is indentification of improving neighborhoods or best neighbor without enumeration of whole neighborhood.
Ejection Chain e.g. Capacitated Vehicle Routing Problem"><meta itemprop=datePublished content="2021-10-10T00:00:00+00:00"><meta itemprop=dateModified content="2021-10-10T00:00:00+00:00"><meta itemprop=wordCount content="951"><meta itemprop=image content="https://rand-notes.github.io"><meta itemprop=keywords content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rand-notes.github.io"><meta name=twitter:title content="lec 2"><meta name=twitter:description content="Neighborhoods Definition: Function of neighborhood N is mapping \( N: S \rightarrow 2^S \), which assign every solution s from Z, set of solutions \( N(S) \subset S \)
Effective Algorithms for Searching in Very Large Neighborhoods space size: polynom of higher order of magnitude (n > 2)
main problem is indentification of improving neighborhoods or best neighbor without enumeration of whole neighborhood.
Ejection Chain e.g. Capacitated Vehicle Routing Problem"><meta property="og:title" content="lec 2"><meta property="og:description" content="Neighborhoods Definition: Function of neighborhood N is mapping \( N: S \rightarrow 2^S \), which assign every solution s from Z, set of solutions \( N(S) \subset S \)
Effective Algorithms for Searching in Very Large Neighborhoods space size: polynom of higher order of magnitude (n > 2)
main problem is indentification of improving neighborhoods or best neighbor without enumeration of whole neighborhood.
Ejection Chain e.g. Capacitated Vehicle Routing Problem"><meta property="og:type" content="article"><meta property="og:url" content="https://rand-notes.github.io/fi/iv126/2/"><meta property="og:image" content="https://rand-notes.github.io"><meta property="article:section" content="fi"><meta property="article:published_time" content="2021-10-10T00:00:00+00:00"><meta property="article:modified_time" content="2021-10-10T00:00:00+00:00"><meta property="og:site_name" content="idk"><meta property="article:published_time" content="2021-10-10 00:00:00 +0000 UTC"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo>title</div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/posts>notes</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class="theme-toggle not-selectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=https://rand-notes.github.io/fi/iv126/2/>lec 2</a></h2><div class=post-content><h1 id=neighborhoods>Neighborhoods</h1><p>Definition: Function of neighborhood N is mapping \( N: S \rightarrow 2^S \), which assign every solution s from Z, set of solutions \( N(S) \subset S \)</p><img src=/images/iv126/neighborhoods.png alt=neighborhoods class=center><h1 id=effective-algorithms-for-searching-in-very-large-neighborhoods>Effective Algorithms for Searching in Very Large Neighborhoods</h1><p>space size: polynom of higher order of magnitude (n > 2)</p><p>main problem is indentification of improving neighborhoods or best neighbor without enumeration of whole neighborhood.</p><h1 id=ejection-chain>Ejection Chain</h1><p>e.g. Capacitated Vehicle Routing Problem</p><p>ejection chain: sequence of moving customer from one round to next one:</p><ul><li>each ejection chain includes k levels starting at round 1 and ending at round k</li><li>vertex is removed from round 1 and moved to round 2, vertex from round 2 is moved to round 3 and so on until vertex k-1 to k, last vertex from round is moved to round 1.</li></ul><p>succesful change: no vertex is in solution more than once</p><p>ejection chain must be cyclic. This can be satisfied with placing last consistently last customer to last round.</p><img src=/images/iv126/ejection-chain.png alt=neighborhoods class=center><h1 id=cyclic-exchange-in-groups>Cyclic Exchange in Groups</h1><p>Problems with dividing n elements to q groups</p><p>/todo</p><h1 id=incremental-evaluation-of-neighborhood>Incremental Evaluation of Neighborhood</h1><p>Evaluation of solution is most expensive part of computation.</p><p><strong>Naive Evaluation</strong>: complete evaluation of every solution in neighborhood.</p><p>Goal: Design suitable incremental evaluation of neighborhood.</p><p>e.g.</p><img src=/images/iv126/k-opt.png class=center><p>$$ \delta f = distance(A, E) + distance(C, D) - distance(A, D) - distance(C, E)$$</p><h1 id=local-space-seach>Local Space Seach</h1><h2 id=2-opt>2-opt</h2><p>Simple local search algorithm for solving the traveling salesman problem. The main idea behind it is to take a route that crosses over itself and reorder it so that it does not.</p><img src=/images/iv126/2opt.png class=center><h2 id=selection-of-neighbor-from-neighborhood>Selection of Neighbor from Neighborhood</h2><p><strong>Steepest descent</strong> - selecting the best neighbor (i.e. neighbor that most improve objective function)
<strong>First Improving</strong> - systematic/deterministic selection of first neighborhood that is better than current solution
<strong>Random Selection</strong> - random selection from improving neighbors.</p><h1 id=state-space>State Space</h1><p>is defined by oriented graph G = (S, E), where set of vertices S corresponds to problem solutions defined by their representations and set of edges E is defined by operator of change used for generating
neighbors.</p><h1 id=landscape>Landscape</h1><p>Landscape I is defined by pair (G, f), where G is state space and f is objective function, which is used for search.</p><h1 id=fitness-landscape>Fitness Landscape</h1><p>Also called adaptive landscapes are used in evolution algorithms for visualization of relationship between genotypes and reproductive success.</p><h1 id=accept-nonimproving-neighbors>Accept Nonimproving Neighbors</h1><h2 id=simulated-annealing>Simulated Annealing</h2><p>SA use random selection of neighbor from neighborhood. Selection of better neighbor is always accepted (as is at Hill Climbing) but accept also a worse neighbor.
At start of search there is allowed bigger probability of worsening the solution, gradually the probability is decreasing.</p><h2 id=threshold-accepting>Threshold Accepting</h2><p>Deterministic variant of SA.
Accept also worse solutions with max deterioration of threshold value Q.</p><h2 id=great-deluge-algorithm>Great Deluge Algorithm</h2><p>Analogy with flood and rising water surface. Climber (solution quality) always remain above water surface.</p><p>Algorithm for minimalization problems: we must decrese surface and we are trying to remain under surface</p><ul><li>If we are rising to quickly we found poor quality solution.</li><li>When rising the computational complexity is also increasing.</li></ul><h2 id=tabu-search>Tabu search</h2><p>Deterministic extension of basic state space search algorithm. Often combined with other algorithms.</p><p>Allow to accept also worse solutions. Solution of worse quality is accepted when there is no better.
Cycles are prevented by so called tabu list.</p><p><strong>Tabu list</strong><br>List with N last changes, which are forbidden. N is typically 5 to 9.</p><p><strong>Aspiration Criteria</strong><br>Condition with which it&rsquo;s also possible to make changes included in Tabu List.
e.g. allowing changes that leads to better value of objective function.</p><h1 id=iterative-with-different-solutions>Iterative With Different Solutions</h1><h2 id=multistart-local-seach>Multistart Local Seach</h2><p>Repeating of local search. Initial Solution is randomly generated with every new iteration.</p><h2 id=iterative-local-search>Iterative Local Search</h2><p>Improving of Multistart Local Search. Found local optima is changed and used at next local search. Can be used with any local search algorithm.</p><h1 id=change-landscape-of-the-problem>Change Landscape of the Problem</h1><h2 id=different-neighborhoods>Different Neighborhoods</h2><h3 id=variable-neighborhood-search>Variable Neighborhood Search</h3><p>The idea is we are using another landscape to get out of local optima.</p><p>e.g. planning school timetable - to find some better solution, we can move one lecture to empty place, or we can move 10 lectures, which gives us more space to work (and to find better solution), but we
also need to compute more. So we often work with &rsquo;embedded neighborhoods&rsquo;. Neighborhood i represents change of i + 1 lectures in timetable.</p><img src=/images/iv126/vns.png alt=vns class=center><h3 id=variable-neighborhood-descent>Variable Neighborhood Descent</h3><p>VNS based on improving search with variable neighborhood. VND is deterministic version of VNS.</p><p>If we take school timetable - It&rsquo;s not needed to move 10 lectures if 2 is enough, so after each improvment we are going back</p><img src=/images/iv126/vnd.png alt=vns class=center><p>note: There are also nondeterministic variants working on similar principle.</p><h1 id=change-of-the-objective-function-or-the-data-input>Change of the Objective Function or the Data Input</h1><h2 id=guided-local-seach>Guided Local Seach</h2><p>repeated local searches with modified value of objective function.
Every solution \( s \in S \) has set m characteristics with price \( c_i \)</p><p>$$ I_i(s) = 1 if s has characteristic i else 0 $$</p><p>effor to search within a part of space with lower prices of characteristics.
e.g. TSP: if edge (a, b) is in solution, price is determined by edge lenght (cities distance).</p><p>New objective function:</p><p>$$
f&rsquo;(s) = f(s) \lambda \sum^m_{i=1} p_i I_i(s)
$$</p><p>penalization p_i: meaning of characteristic (we don&rsquo;t want big penalization). \( p_i \) is initialized to 0 for every i. \( \lambda \) is used for normalization</p><p>In TSP characteristic is one route (edge) of graph.</p><p>Characteristic with highest utility (hodnota) \(u_i(s) = I_i(s) \frac{c_i}{1+p_i} \) is penalized. Next time we want to avoid characteristics with high price. Characteristics used in solutions get
penalized for support of diversification.</p><p>Intensification:</p><ul><li>GLS search through space with lower prices \( c_i \)</li></ul><p>Diversification:</p><ul><li>Characteristics used in generated local optima are penalized to avoid them next time.</li></ul><p>/todo example</p></div></article><hr><div class=post-info></div></main></div><footer class=footer></footer><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script></div><script type=text/javascript src=/bundle.min.e8a56c89d5ca304d6922b22e38d0af2db97fa70a6623ba17a492092da773dfa4b9aaffa0f682ecfd03d7c7964e89bdbef18f0d4183c698831978c7ca44959d10.js integrity="sha512-6KVsidXKME1pIrIuONCvLbl/pwpmI7oXpJIJLadz36S5qv+g9oLs/QPXx5ZOib2+8Y8NQYPGmIMZeMfKRJWdEA=="></script></body></html>