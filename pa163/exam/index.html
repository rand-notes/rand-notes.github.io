<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="ie=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=author content>
<meta name=description content="funfacts  Hranová konzistence je směrová - konzistence hrany (Vi, Vj) nezaručuje konzistenci hrany (Vj, Vi) Použitím AC odstraníme mnoho nekompatibilních hodnot, ale nedostame reseni problemu ani nevime jestli reseni existuje. PC ⇒ AC, ale AC !⇒ PC  CSP na binarni pomoci dualniho problemu vezmeme podminku C_i a prevedeme ji na V_i, ktera bude obsahovat n-tice hodnot, ktere splnuji podminku.
napr. C1 = C + E &amp;gt; 2, kde C ma domenu {1,2,3} a E ma domenu {0,1}.">
<meta name=keywords content>
<meta name=robots content="noodp">
<meta name=theme-color content>
<link rel=canonical href=https://rand-notes.github.io/pa163/exam/>
<title>
exam PA163 :: idk
</title>
<link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css rel=stylesheet type=text/css>
<link rel=stylesheet href=/main.7209ab6422eb371a6b685a56274cc88eff3db604665c3bdb698389c0585d4211.css>
<meta itemprop=name content="exam PA163">
<meta itemprop=description content="funfacts  Hranová konzistence je směrová - konzistence hrany (Vi, Vj) nezaručuje konzistenci hrany (Vj, Vi) Použitím AC odstraníme mnoho nekompatibilních hodnot, ale nedostame reseni problemu ani nevime jestli reseni existuje. PC ⇒ AC, ale AC !⇒ PC  CSP na binarni pomoci dualniho problemu vezmeme podminku C_i a prevedeme ji na V_i, ktera bude obsahovat n-tice hodnot, ktere splnuji podminku.
napr. C1 = C + E > 2, kde C ma domenu {1,2,3} a E ma domenu {0,1}.">
<meta itemprop=wordCount content="3395"><meta itemprop=image content="https://rand-notes.github.io">
<meta itemprop=keywords content>
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://rand-notes.github.io">
<meta name=twitter:title content="exam PA163">
<meta name=twitter:description content="funfacts  Hranová konzistence je směrová - konzistence hrany (Vi, Vj) nezaručuje konzistenci hrany (Vj, Vi) Použitím AC odstraníme mnoho nekompatibilních hodnot, ale nedostame reseni problemu ani nevime jestli reseni existuje. PC ⇒ AC, ale AC !⇒ PC  CSP na binarni pomoci dualniho problemu vezmeme podminku C_i a prevedeme ji na V_i, ktera bude obsahovat n-tice hodnot, ktere splnuji podminku.
napr. C1 = C + E > 2, kde C ma domenu {1,2,3} a E ma domenu {0,1}.">
<meta property="og:title" content="exam PA163">
<meta property="og:description" content="funfacts  Hranová konzistence je směrová - konzistence hrany (Vi, Vj) nezaručuje konzistenci hrany (Vj, Vi) Použitím AC odstraníme mnoho nekompatibilních hodnot, ale nedostame reseni problemu ani nevime jestli reseni existuje. PC ⇒ AC, ale AC !⇒ PC  CSP na binarni pomoci dualniho problemu vezmeme podminku C_i a prevedeme ji na V_i, ktera bude obsahovat n-tice hodnot, ktere splnuji podminku.
napr. C1 = C + E > 2, kde C ma domenu {1,2,3} a E ma domenu {0,1}.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://rand-notes.github.io/pa163/exam/"><meta property="og:image" content="https://rand-notes.github.io"><meta property="article:section" content="fi">
<meta property="og:site_name" content="idk">
</head>
<body>
<div class=container>
<header class=header>
<span class=header__inner>
<a href=/ style=text-decoration:none>
<div class=logo>
title
</div>
</a>
<span class=header__right>
<nav class=menu>
<ul class=menu__inner><li><a href=/posts>notes</a></li>
</ul>
</nav>
<span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span>
<span class="theme-toggle not-selectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span>
</span>
</span>
</header>
<div class=content>
<main class=post>
<div class=post-info>
</p>
</div>
<article>
<h2 class=post-title><a href=https://rand-notes.github.io/pa163/exam/>exam PA163</a></h2>
<div class=post-content>
<h1 id=funfacts>funfacts</h1>
<ul>
<li>Hranová konzistence je směrová - konzistence hrany (Vi, Vj) nezaručuje konzistenci hrany (Vj, Vi)</li>
<li>Použitím AC odstraníme mnoho nekompatibilních hodnot, ale nedostame reseni problemu ani nevime jestli reseni existuje.</li>
<li>PC ⇒ AC, ale AC !⇒ PC</li>
</ul>
<h1 id=csp-na-binarni-pomoci-dualniho-problemu>CSP na binarni pomoci dualniho problemu</h1>
<p>vezmeme podminku C_i a prevedeme ji na V_i, ktera bude obsahovat n-tice hodnot, ktere splnuji podminku.</p>
<p>napr. C1 = C + E > 2, kde C ma domenu {1,2,3} a E ma domenu {0,1}. potom: V4 = {(2,1), (3,0), (3,1)}</p>
<p>V bloky propojime podle toho jak se rovnaji promenne v podminkach</p>
<p>napr. c1 : A + D + F = 1, c2 : A − C + D = 1 ==> propojime s R11 & R23</p>
<h1 id=ac-1-a-ac-3>AC-1 a AC-3</h1>
<p>U algoritmu AC-1 dochází k revizi všech hran pokaždé, kdy se doména některé z proměnných
změní. U algoritmu AC-3 se hrany k zrevidování berou z fronty. Do té se na začátku vloží hrany
všechny a pokaždém pruchodu se vloží pouze ty hrany, které mohou být zasaženy některou z případných změn domén</p>
<p>pr. <code>A∈{1, ..., 10}, B∈{1, ..., 10}, C∈{1, ..., 10}, B &lt; A, A ≤C + 4</code></p>
<h1 id=podpora>Podpora</h1>
<p>Vytvarime tzv. podpory mezi promennymi, pokud vime ze pokud domena promenne V1 bude a, tak V2
musi byt. b nebo c, tak vytvorime podpory mezi ab a ac. Vyhoda je v tom, ze jakmile odstranime
hodnotu ve V1, tak ve V2 nemusime kontrolovat vsechny hodnoty, ale zkontrolujeme pouze podpory.
Pokud ma dana hodnota i jinou podporu mezi V1 a V2 pak se necha jinak se hodnota odstrani z
domeny.</p>
<h1 id=k-konzistence>K konzistence</h1>
<ul>
<li>AC: rozšiřujeme jednu hodnotu do druhé proměnné</li>
<li>PC: rozšířujeme dvojici hodnot do třetí proměnné</li>
</ul>
<p>CSP je k-konzistentní právě tehdy, když můžeme libovolné
konzistentní ohodnocení (k-1) různých proměnných rozšířit do libovolné k-té proměnné</p>
<h1 id=obecné-hranové-konzistence-gac>Obecné Hranové Konzistence (GAC)</h1>
<p>někdy nazývána doménová konzistence</p>
<p>CSP je obecně hranově konzistentní <code>&lt;=></code> všechna jeho omezení jsou obecně hranově konzistentní</p>
<ul>
<li>Uspořádaný graf je graf s lineárním uspořádáním vrcholů.</li>
<li>Šířka vrcholu v uspořádaném grafu je počet hran vedoucích z tohoto vrcholu do předchozích vrcholů.</li>
<li>Šířka uspořádaného grafu je maximum z šířek jeho vrcholů.</li>
<li>Šířka grafu je minimum z šířek všech jeho uspořádaných grafů.</li>
</ul>
<p>pro zjisteni sirky grafu vezmeme vsechny jeho uzly a zjistime nejmensi pocet hran vedouci z
nejakeho uzlu</p>
<h1 id=adaptivní-konzistence-adc>Adaptivní konzistence (ADC)</h1>
<h1 id=backtracking>Backtracking</h1>
<p>rozsirime aktualni uzel a pak vsechny jeho deti zkousime z podminek a vyradime ty ktere neprojdou.</p>
<h1 id=forward-checking>Forward-checking</h1>
<p>na zacatku rozsirime vsechny uzly, pomoci prvni podminky omezime domenu dalsi promenne. Pokud nam
nezbyde zadna volna hodnota tak konec, jinak rozsirime jenom ty deti ktere prosli podminkou.</p>
<h1 id=look-ahead>Look-Ahead</h1>
<p>Prvni krok stejny jako Forward-checking, ale po redukci domeny zaroven redukujeme i dalsi domeny
podle nasledujicich podminek (pomoci jiz redukovanych domen). Pokracujeme ve vetvi jen pokud
existuje ve vsech domenach aspon 1 hodnota.</p>
<ul>
<li>Thrashing: opakované objevování stejných nekonzistencí a částečných úspěchů při prohledávání</li>
<li>Algoritmy pohledu dopředu kontrolují podmínky dopředu
<ul>
<li>backtracking odhalí nesplnění podmínky teprve když přiřadí hodnoty jejím proměnným</li>
<li>konzistenčními algoritmy lze předem upravit domény A a E</li>
</ul>
</li>
<li>Backjumping se vrací k původci chyby
<ul>
<li>backtracking vyzkouší všechny možnosti pro B,C,D než odhalí A!=1 hned po prvním neúspěšném přiřazení E se lze vrátit k přiřazování A</li>
</ul>
</li>
<li>Dynamický backtracking: změna uspořádání minulých proměnných</li>
<li>Neúplná prohledávání: hledání pouze v některých částech stavového prostoru</li>
</ul>
<h1 id=pohledy-dopredu>Pohledy dopredu</h1>
<h2 id=kontrola-dopředu-forward-checking-fc>Kontrola dopředu (forward checking) FC</h2>
<p>FC zajišťuje konzistenci mezi aktuální proměnnou a budoucími proměnnými, které jsou s ní spojeny dosud nesplněnými podmínkami</p>
<h2 id=rfla--la>RFLA == LA</h2>
<h2 id=úplný-pohled-dopředu-full-look-ahead-fla>Úplný pohled dopředu (full look-ahead) FLA</h2>
<p>pouze jeden průchod repeat until cyklem algoritmu</p>
<h2 id=částečný-pohled-dopředu-partial-look-ahead-pla>Částečný pohled dopředu (partial look-ahead) PLA</h2>
<p>pouze jeden průchod repeat until cyklem algoritmu
nahrazuje <code>for ∀ k, k != j, i &lt; k ≤ n</code> výrazem <code>for ∀ k, j &lt; k ≤ n</code>
tj. budoucí proměnné porovnávány pouze s těmi, které je následují, tj. DAC</p>
<h1 id=výběr-hodnoty>Výběr hodnoty</h1>
<p>Jakým způsobem vybírat ze zbývajích hodnot v doméně proměnné?</p>
<p>Triviální výběr hodnoty:</p>
<ul>
<li>doména procházena ve vzrůstajícím pořadí</li>
<li>doména procházena v klesajícím pořadí</li>
</ul>
<p>Obecný princip výběru hodnoty: první úspěch (succeed first)</p>
<h2 id=minimální-konflikt>Minimální konflikt</h2>
<ul>
<li>výběr hodnoty, která smaže nejmenší počet hodnot z domén budoucích proměnných</li>
<li>experimentálně: tato heuristika vykazuje velmi dobré výsledky</li>
</ul>
<h2 id=maximální-velikost-domény>Maximální velikost domény</h2>
<p>výběr hodnoty, která způsobí vytvoření největší minimální velikost domény mezi všemi budoucími proměnnými
intuice: proměnné, které mají malé domény, způsobí pravděpodobněji nekonzistenci</p>
<h1 id=výběr-proměnných-statický>Výběr proměnných: statický</h1>
<h2 id=statické-uspořádání-proměnných-výběr-proměnných-dán-předem>Statické uspořádání proměnných: výběr proměnných dán předem</h2>
<ul>
<li>triviálně: výběr nejlevější proměnné tj. proměnné s nejmenším indexem</li>
</ul>
<h2 id=maximální-kardinalita>Maximální kardinalita</h2>
<ul>
<li>první proměnnou (uzel grafu) vybereme náhodně</li>
<li>každý uzel je spojen s maximálním počtem už uspořádaných (= dříve vybraných) vrcholů</li>
<li>proměnné vybíráme v pořadí dle tohoto počtu vrcholů</li>
</ul>
<h2 id=minimální-šířka>Minimální šířka</h2>
<ul>
<li>proměnné uspořádány tak, aby byla minimalizována šířka grafu (minimalizován počet zpětných hran)</li>
<li>odzadu vybíráme proměnné s nejmenším počtem hran v aktualizovaném grafu (algoritmus viz dříve)</li>
</ul>
<h1 id=výběr-proměnných-dynamický>Výběr proměnných: dynamický</h1>
<p>Dynamické uspořádání proměnných: výběr proměnných počítán až v průběhu prohledávání</p>
<h2 id=first-fail>First-fail</h2>
<ul>
<li>velmi často používaná metoda (vhodná jako default)</li>
<li>výběr proměnné, která nejvíce omezí zbytek stavového prostoru</li>
<li><strong>vybereme proměnnou s nejmenší doménou</strong></li>
<li>později už by mohlo být těžší pro tuto proměnnou nalézt správnou hodnotu</li>
<li>kombinace first-fail a maximální kardinality</li>
<li><code>A, B, C ∈ {1, 2, 3}, A &lt; 3, A = B + C</code> nejlépe je začít s výběrem A</li>
</ul>
<h1 id=silnější-pohled-dopředu>Silnější pohled dopředu</h1>
<p>Algoritmy pohledu dopředu zatím uvažovaly pouze hranovou konzistenci
Po každém přiřazení hodnoty proměnné lze vyžadovat dosažení vyššího stupně konzistence</p>
<h1 id=přehled-typů-algoritmů-pohledu-zpět-look-back>Přehled typů algoritmů pohledu zpět look-back</h1>
<h2 id=algoritmy-skoku-zpět-backjumping>Algoritmy skoku zpět (backjumping)</h2>
<ul>
<li>při zpětném průchodu se nevracíme pouze jeden krok jako algoritmus backtrackingu</li>
<li>snažíme se vracet co nejdále až ke zdroji chyby</li>
</ul>
<h2 id=algoritmy-učení-constraint-recording-no-good-learning>Algoritmy učení (constraint recording, no-good learning)</h2>
<ul>
<li>no-good = chybné částečné přiřazení</li>
<li>přidáme nová omezení, která zakazují nalezená chybná přiřazení</li>
</ul>
<h2 id=dynamický-backtracking>Dynamický backtracking</h2>
<ul>
<li>při skoku zpět se snažíme nezapomínat na už udělanou práci</li>
<li>měníme hodnoty pouze u minulých proměnných s konfliktem</li>
<li>realizace: změníme uspořádání proměnných</li>
</ul>
<h2 id=backmarking>Backmarking</h2>
<ul>
<li>pamatuje si, kde testy na konzistenci neuspěly</li>
<li>eliminuje opakování dříve provedených konzistenčních testů</li>
</ul>
<h1 id=konfliktní-množina>Konfliktní množina</h1>
<ul>
<li>Jestliže neexistuje hodnota b z domény x tak, aby (a, x) bylo konzistentní, říkáme, že a je konfliktní množina x a nebo, že a je v konfliktu s x.</li>
<li>Pokud a neobsahuje j-tici <code>(j &lt; k)</code>, která je v konfliktu s x, pak nazýváme a minimální konfliktní množina.</li>
</ul>
<h1 id=chybné-přiřazení>Chybné přiřazení</h1>
<ul>
<li>Částečné přiřazení a, které se nevyskytuje v žádném řešení CSP, se nazývá chybné přiřazení (no-good ).</li>
<li>konfliktní množiny jsou chybná přiřazení.</li>
<li>Minimální chybná přiřazení neobsahují chybná přiřazení méně proměnných</li>
</ul>
<h2 id=přiřazení-je-konfliktní-množinou-i-chybným-přiřazením>Přiřazení je konfliktní množinou i chybným přiřazením</h2>
<p>Takové přiřazení, které nám znemožní přiřadit další proměnné hodnotu a proto nedokážeme udělat
řešení konzistentní a samotné řešení tedy není validní</p>
<h2 id=přiřazení-není-konfliktní-množinou-i-chybným-přiřazením>Přiřazení není konfliktní množinou i chybným přiřazením</h2>
<p>Takové přiřazení, které splňuje podmínky a je zárověň i řešením.</p>
<h2 id=přiřazení-je-konfliktní-množinou-ale-není-chybným-přiřazením>Přiřazení je konfliktní množinou, ale není chybným přiřazením</h2>
<p>Takové přiřazení neexistuje, protože každá konfliktní množina je chybné přiřazení vzhledem k
jedné proměnné.</p>
<h2 id=přiřazení-není-konfliktní-množinou-ale-je-chybným-přiřazením>Přiřazení není konfliktní množinou, ale je chybným přiřazením</h2>
<p>Přiřadíme hodnotu nějaké proměnné (popř. několik hodnot proměnným) tak, že hodnoty splňují
všechny podmínky, ale nemohou se zároveň vyskytovat v řešení.</p>
<h1 id=konfliktní-proměnná>Konfliktní proměnná</h1>
<p>Pokud víme, že x_j je chybné přiřazení pak víme že x_j je bezpečná. Protože pokud při backtracking skočíme zpátky na x_j pak si
můžeme být jistí, že jsme nepřeskočili žadné řešení.</p>
<h1 id=gaschnigs-backjumping-gbj>Gaschnig’s backjumping (GBJ)</h1>
<p>Když nedokážeme přiřadit hodnotu proměnné xi, vracíme se zpět (skáčeme zpět) ke konfliktní proměnné.</p>
<p>Určení konfliktní proměnné:</p>
<ul>
<li>pro každou hodnotu vi ∈ xi nalezneme proměnnou s nejmenším indexem, která je s xi /vi v konfliktu (přiřazení této proměnné musíme určitě změnit, aby šla hodnota vi použít)</li>
<li>konfliktní proměnná je ta z nich, která má největší index (když její hodnotu změníme, můžeme zrušit konflikt s odpovídající hodnotou)</li>
</ul>
<h1 id=konflikty-řízený-skok-zpět-conflict-directed-backjumping-cbj>Konflikty řízený skok zpět (Conflict-directed backjumping CBJ)</h1>
<p>Při skoku zpět na proměnnou xj z listu slepé větve nemusíme nalézt v doméně xj
žádné hodnoty pro přiřazení. aj−1 se pak nazývá vnitřní slepá větev.</p>
<p>CBJ skáče zpět v listu slepé větve i ve vnitřní slepé větvi:</p>
<ul>
<li>udržujeme Ji množinu skoků zpět pro každou proměnnou pomocí nesplněných omezení</li>
<li><code>xj (j &lt; i)</code> je bližší k xi než <code>xk (k &lt; i)</code>, jestliže <code>k &lt; j</code>. Naopak xk je vzdálenější</li>
<li>omezení R je vzdálenější než omezení S, jestliže je nejbližší proměnná v rozsahu R vzdálenější než nejbližší proměnná v rozsahu S (pokud totožné proměnné, rozhodují další proměnné).</li>
<li>mezi nesplněnými omezeními vybereme to nejvzdálenější (ostatní omezení neumožní nejdelší možný skok zpět)</li>
<li>skočíme zpět na nejbližší proměnnou v tomto omezení (je bezpečné změnit proměnnou, která byla nejpozději přiřazená)</li>
</ul>
<h1 id=algoritmy-učení>Algoritmy učení</h1>
<ul>
<li>Množiny skoků zpět jsou chybná přiřazení vypočítaná během prohledávání</li>
<li>Tato chybná přiřazení se mohou vyskytovat i později v jiných cestách stromu prohledávání a jsou znovu počítána</li>
<li>Přidáme chybná přiřazení jako nová omezení při detekci slepé větve</li>
<li>nemá cenu uchovávat celou slepou větev ~ai v proměnné xi+1 na toto přiřazení už později nenarazíme</li>
<li>uchováme chybná přiřazení na podmnožině proměnných {x1, &mldr;, xi }</li>
<li>Prořezávání stavového prostoru: čím menší chybná přiřazení se podaří uchovat, tím rychlejší bude prohledávání</li>
<li>Zvětšování množiny omezení: cena za prořezávání stavového prostoru nesmí přerůst cenu za zvětšování množiny omezení</li>
</ul>
<h1 id=učení-skoku-zpět-jumpback-learning>Učení skoku zpět (jumpback learning)</h1>
<ul>
<li>Využijeme chybná přiřazení, která jsme se naučili v CBJ</li>
<li>Algoritmus učení skoku zpět ≡ CBJ + přidávání nových omezení</li>
<li>Po dosažení listu slepé větve ~ai−1 přidáme omezení zakazující ~ai−1[Ji]</li>
</ul>
<h1 id=problémy-skoku-zpět>Problémy skoku zpět</h1>
<p>Při skoku zpět zapomínáme už udělanou práci</p>
<p><strong>dynamický backtracking</strong> = Skok zpět + pamatování si důvodu konfliktu + přenos důvodu konfliktu + změna pořadí proměnných</p>
<p>Nevýhody dynamickeho backtrackingu: přeuspořádáváním proměnných rušíme efekt heuristik výběru proměnných</p>
<h1 id=neúplné-prohledávání-do-hloubky>Neúplné prohledávání do hloubky</h1>
<ul>
<li>Neprohledáváme celý stavový prostor</li>
<li>Nemáme záruku, že řešení neexistuje, i když ho algoritmus nenalezne</li>
<li>V řadě případů najdeme řešení rychleji</li>
<li>Neúplné algoritmy často odvozeny od algoritmu úplného (DFS)
<ul>
<li>přerušení běhu algoritmu (cutoff): po vyčerpání přiděleného prostředku (prostředek může být globální i lokalni)</li>
<li>opakovaní běhu algoritmu (restart) s jinym nastavenim</li>
</ul>
</li>
</ul>
<h2 id=depth-first-search-dfs>Depth first search (DFS)</h2>
<ul>
<li>odpovídá algoritmu backtrackingu</li>
<li>Reálné problémy mají často tak velké prostory možných ohodnocení, že není možné je celé prohledat.</li>
<li>možné prohledat jen omezený prostor -> Neúplná stromová prohledávání</li>
<li>Neúplné prohledávání do hloubky</li>
</ul>
<h2 id=randomizovaný-backtracking>Randomizovaný backtracking</h2>
<ul>
<li>časově omezený backtracking (přerušení)</li>
<li>běh (úplného) algoritmu ukončíme po zadaném časovém intervalu</li>
<li>časový interval lze pro další běhy zvětšit</li>
<li>náhodný výběr hodnot a proměnných (opakování)</li>
<li>pokud máme možnost volby při výběru hodnot nebo proměnných náhodně zvolíme některou z nich</li>
</ul>
<h2 id=randomizovaný-backtracking-s-učením>Randomizovaný backtracking s učením</h2>
<ul>
<li>chybná přiřazení předchozích běhů uchováme a využíváme</li>
<li>takto lze také dosáhnout úplnosti, protože chybných přiřazení je konečně mnoho</li>
</ul>
<h1 id=omezení-počtu-návratů---bounded-backtrack-search-bbs>Omezení počtu návratů - Bounded-backtrack search (BBS)</h1>
<p>Omezený počet návratů (přerušení)</p>
<ul>
<li>návrat do bodů volby, kde už nelze vybrat novou hodnotu nezapočítáváme</li>
</ul>
<p>Pro úplnost: při neúspěchu zvětšíme počet návratů o jedna (opakování)</p>
<h1 id=omezení-hloubky---depth-bounded-search-dbs>Omezení hloubky - Depth-bounded search (DBS)</h1>
<p>Omezíme hloubku prohledávaného stromu (přerušení)</p>
<ul>
<li>do dané hloubky stromu se zkouší všechny alternativy</li>
<li>ve zbytku stromu se může použít jiná neúplná metoda</li>
</ul>
<p>Pro úplnost: při neúspěchu zvětšíme hloubku prohledávání o jedna (opakování)</p>
<p>napr. DBS(1, BBS(0)) - prohledava pouze nejlevejsi vetve do hloubky</p>
<h1 id=prohledávání-s-kreditem---credit-search-cs>Prohledávání s kreditem - Credit search (CS)</h1>
<p>Omezený kredit (počet návratů) pro prohledávání (přerušení)</p>
<ul>
<li>kredit se rovnoměrně dělí mezi alternativní větve prohledávání</li>
<li>jednotkový kredit zakazuje možnost volby (hodnoty), tj. pokračujeme pouze bez návratů</li>
</ul>
<p>Pro úplnost: při neúspěchu navýšíme kredit o jedna (opakování)</p>
<h1 id=iterativní-rozšiřování---iterative-broadening-ib>Iterativní rozšiřování - Iterative broadening IB</h1>
<p>Omezený maximální počet voleb (hodnot) - při každém výběru proměnné (přerušení)</p>
<ul>
<li>v každém bodě volby větvení omezeno konstantou</li>
<li>při překročení max. počtu voleb pokračujeme předchozím bodem volby</li>
</ul>
<p>Úplnost: při neúspěchu zvýšíme povolený počet voleb o jedna (opakování)</p>
<p>Implementace: po výběru proměnné umožníme pouze výběr určeného počtu jejích hodnot</p>
<h1 id=stromová-prohledávání-a-heuristiky>Stromová prohledávání a heuristiky</h1>
<p>Při řešení reálných problémů často existuje nápověda odvozená ze zkušeností s „ručním” řešením problému</p>
<p>Heuristiky – radí, jak pokračovat v prohledávání</p>
<ul>
<li>doporučují hodnotu pro přiřazení</li>
<li>často vedou přímo k řešení</li>
</ul>
<p>Co dělat, když heuristika neuspěje?</p>
<ul>
<li>DFS se stará hlavně o konec prohledávání (spodní část stromu)</li>
<li>DFS tedy spíše opravuje poslední použité heuristiky než první</li>
<li>DFS předpokládá, že dříve použité heuristiky ho navedly dobře</li>
</ul>
<p>Pozorování</p>
<ul>
<li>počet porušení heuristiky na úspěšné cestě je malý</li>
<li>heuristiky jsou méně spolehlivé na začátku prohledávání než na jeho konci (na konci máme více informací a méně možností)</li>
</ul>
<h1 id=zotavení-se-z-chyb-heuristiky>Zotavení se z chyb heuristiky</h1>
<ul>
<li>Heuristika doporučuje hodnotu pro přiřazení</li>
<li><strong>Diskrepance</strong> = porušení heuristiky (použita jiná hodnota, než doporučila heuristika)</li>
<li>Pozorování: málo chyb heuristiky na cestě k řešení (cesty s méně diskrepancemi jsou prozkoumány dříve)</li>
<li>Pozorování: chyby heuristiky hlavně na začátku cesty (cesty s diskrepancemi na začátku jsou prozkoumány dříve)</li>
</ul>
<h1 id=omezené-diskrepance>Omezené diskrepance</h1>
<p>Limited discrepancy search (LDS)
Omezený maximální počet diskrepancí na cestě (přerušení)</p>
<ul>
<li>cesty s diskrepancemi na začátku jsou prozkoumány dříve
Při neúspěchu navýšíme</li>
<li>počet povolených diskrepancí o jedna (opakování)</li>
<li>tj. nejprve jdeme tak, jak doporučuje heuristika; potom jdeme po cestách s maximálně jednou diskrepancí; pak maximálně se dvěma diskrepancemi, atd.</li>
</ul>
<p>Diskrepance pro nebinární domény:</p>
<ul>
<li>nedoporučené hodnoty se berou jako jedna diskrepance</li>
<li>výběr každé další hodnoty proměnné je jedna diskrepance</li>
</ul>
<h1 id=omezené-diskrepance--zlepšení>Omezené diskrepance – zlepšení</h1>
<p>LDS v každé další iteraci prochází i větve z předchozí iterace, tj. opakuje již provedený výpočet a navíc se v rámci iterace musí vracet do již prošlých částí</p>
<h2 id=improved-limited-discrepancy-search-ilds>Improved limited discrepancy search (ILDS)</h2>
<p>daný počet diskrepancí na cestě (přerušení): cesty s diskrepancemi na konci prozkoumány dříve</p>
<p>Při neúspěchu navýšíme počet diskrepancí o jedna (opakování)</p>
<h1 id=hloubkou-omezené-diskrepance>Hloubkou omezené diskrepance</h1>
<p>ILDS bere cesty s diskrepancemi na konci dříve<br>
Depth-bounded discrepancy search (DDS)<br>
Diskrepance povoleny pouze do dané hloubky (přerušení)</p>
<ul>
<li>v této hloubce je vždy diskrepance, tj. zabrání se procházení větví z předchozí iterace</li>
<li>hloubka zároveň omezuje maximální počet diskrepancí</li>
<li>cesty s diskrepancemi na začátku prozkoumány dříve
Při neúspěchu navýšíme hloubku o jedna (opakování)</li>
</ul>
<h1 id=lokální-prohledávání-ls>Lokální prohledávání (LS)</h1>
<p>pracuje s úplnými nekonzistentními přiřazeními proměnných
snaží se lokálními opravami snížit počet konfliktů</p>
<p>Heuristická metoda prohledávání:</p>
<ul>
<li>neúplná metoda</li>
<li>nezaručuje nalezení (vyloučení existence) řešení i když existuje (neexistuje)</li>
<li>malé paměťové nároky</li>
</ul>
<p>Ne-striktní lokální optimum: stav, v jehož okolí exisují stavy se stejnou evaluací; není globálním optimum</p>
<h1 id=metoda-největšího-stoupání-hill-climbing--hc>Metoda největšího stoupání (hill climbing ) HC</h1>
<h1 id=metoda-minimalizace-konfliktů-mc>Metoda minimalizace konfliktů (MC)</h1>
<h1 id=náhodná-procházka-random-walk-rw>Náhodná procházka (Random Walk) RW</h1>
<p>Jak uniknout z lokálního optima bez restartu? přidáním „šumu” do algoritmu</p>
<p>Pokud se dostaneme do lokálního optima:</p>
<ul>
<li>náhodně zvolíme stav z okolí a pokračujeme jím</li>
<li>tato metoda samostatně k řešení nepovede</li>
<li>potřebuje další směrování v prohledávacím prostoru: lze kombinovat s HC i MC</li>
</ul>
<p>RW kombinujeme s heuristikou pomocí pravděpodobnostního rozložení:</p>
<ul>
<li>pravděpodobnost náhodného kroku je p</li>
<li>např. 0.02 ≤ p ≤ 0.1</li>
<li>pravděpodobnost použití směrové heuristiky je 1 − p</li>
<li>náhodná procházka tedy nahrazuje restart: unik z lokálního minima prostřednictvím náhodného výběru</li>
</ul>
<h1 id=tabu-seznam>Tabu seznam</h1>
<p>Tabu seznam = seznam tabu (zakázaných) stavů
Aspirační kritérium = odtabuizování stavu (např kdyz krok vede k celkově lepšímu stavu)</p>
<h1 id=výběr-souseda-přehled>Výběr souseda: přehled</h1>
<p>Metoda stoupání (HC)</p>
<ul>
<li>soused s nejlepší evaluací vybrán
Tabu prohledávání (TS+HC)</li>
<li>soused s nejlepší evaluací vybrán (metoda stoupání)</li>
<li>sousedé z tabu seznamu nemohou být vybráni
Minimální konflikt (MC)</li>
<li>soused je omezen na náhodně vybranou konfliktní proměnnou</li>
<li>výběr její hodnoty s nejlepší evaluací
Náhodná procházka (RW)</li>
<li>soused vybrán náhodně
Minimální konflikt (metoda stoupání) s náhodnou procházkou MC+RW (HC+RW)</li>
<li>s malou pravděpodobností: náhodný výběr souseda</li>
<li>jinak: minimální konflikt (metoda stoupání)</li>
</ul>
<h1 id=simulované-žíhání-simulated-annealing-sa>Simulované žíhání (simulated annealing) SA</h1>
<p>Myšlenka: simulace procesu ochlazování kovů</p>
<ul>
<li>na začátku při vyšší teplotě atomy více kmitají a pravděpodobnost změny krystalické mřížky je vyšší</li>
<li>postupným ochlazováním se atomy usazují co „nejlepší polohy” s nejmenší energií a pravděpodobnost změny je menší</li>
<li>na začátku je tedy pravděpodobnost toho, že akceptujeme zhoršování řešení, vyšší</li>
</ul>
<p>Akceptování nového stavu</p>
<ul>
<li>vždy při zlepšení</li>
<li>při zhoršení pouze za dané pravděpodobnosti která klesá se snížením teploty</li>
</ul>
<p>Cykly algoritmu</p>
<ul>
<li>vnější: simulace procesu ochlazování snižováním teploty T</li>
<li>čím nižší bude teplota, tím nižší bude pravděpodobnost akceptování zhoršení</li>
<li>vnitřní: počítáme, kolikrát jsme neakceptovali zhoršení: dán limit MaxIter</li>
</ul>
<h1 id=metropolisovo-kritérium>Metropolisovo kritérium</h1>
<p>Rozdíl mezi kvalitou nového řešení δ a existujícího řešení θ</p>
<p>\( \delta E = E(δ) - E(θ) \)</p>
<p>E (chybovost) musí být minimalizována</p>
<p>Metropolisovo kritérium</p>
<ul>
<li>lepší (někdy případně i stejně kvalitní) řešení akceptováno: \( \delta E \leq 0 \)</li>
<li>horší řešení (∆E > 0) akceptováno pokud: \( U \leq e^{-\delta E/T} \)</li>
</ul>
<p>U náhodné číslo z intervalu (0, 1)</p>
<h1 id=algoritmus-gsat-greedy-sat->Algoritmus GSAT (Greedy SAT )</h1>
<ul>
<li>postupné překlápění proměnných</li>
<li>evaluace udává, jaký je (vážený) počet nesplněných klauzulí</li>
</ul>
<h2 id=heuristiky-pro-gsat>Heuristiky pro GSAT</h2>
<p>GSAT lze kombinovat s různými heuristikami, které zvyšují jeho efektivitu</p>
<ul>
<li>obzvláště při řešení strukturovaných problémů</li>
</ul>
<p>Použití náhodné procházky spolu s minimalizací konfliktů</p>
<p>Vážení klauzulí:</p>
<ul>
<li>některé klauzule zůstávají po řadu iterací nesplněné, klauzule tedy mají různou důležitost</li>
<li>splnění „těžké” klauzule lze preferovat přidáním váhy</li>
<li>váhu může systém odvodit</li>
<li>na začátku mají všechny klauzule stejnou váhu</li>
<li>po každém pokusu zvyšujeme váhu u nesplněných klauzulí</li>
</ul>
<p>Průměrování řešení</p>
<ul>
<li>standardně každý pokus začíná z náhodného řešení</li>
<li>společné části předchozích řešení lze zachovat</li>
<li>restartovací stav se vypočte ze dvou posledních výsledků bitovým srovnáním, stejné bity zachovány, ostatní nastaveny náhodně</li>
</ul>
<h2 id=hybridní-prohledávání>Hybridní prohledávání</h2>
<p>Příklady kombinace lokálního prohledávání a stromoveho prohledavani</p>
<ul>
<li>Lokální prohledávání před nebo po stromovém prohledávání</li>
<li>Stromové prohledávání je doplněno lokálním prohledávání</li>
<li>Lokální prohledávání je doplněno stromovým prohledáváním</li>
</ul>
<h1 id=iterativní-dopředné-prohledávání---iterative-forward-search-ifs>Iterativní dopředné prohledávání - Iterative Forward Search (IFS)</h1>
<p>Hybridní prohledávání: konstruktivní nesystematický algoritmus</p>
<ul>
<li>pracuje nad modelem s pevnými a měkkými omezujícími podmínkami</li>
<li>pevné podmínky: musí být splněny</li>
<li>měkké podmínky: reprezentují účelové funkce, jejichž vážený součet je minimalizován</li>
</ul>
<p>Pracuje s konzistentními přiřazeními</p>
<p>Základní myšlenky (blízký dynamickému backtrackingu)</p>
<ul>
<li>začíná s prázdným přiřazením</li>
<li>vybere novou proměnnou k přiřazení</li>
<li>pokud nalezne konflikt, zruší přiřazení všech proměnných v konfliktu s vybranou proměnnou</li>
<li>výběr hodnot pomocí konfliktní statistiky</li>
<li>výběr proměnných není pro algoritmus kritický, protože lze proměnné přiřadit opakovaně</li>
</ul>
<h1 id=náhodné-problémy>Náhodné problémy</h1>
<p>Algoritmy porovnávány na umělých, náhodně vygenerovaných problémech</p>
<ul>
<li>lze generovat problémy různé obtížnosti (fáze přechodu)</li>
<li>libovolný počet datových instancí</li>
<li>lze testovat, co se stane</li>
</ul>
<p>Náhodné binární CSP (random binary CSP) - parametry (n, m, p1, p2)</p>
<h2 id=fáze-přechodu>Fáze přechodu</h2>
<p>Náhodný k-SAT problém:</p>
<ul>
<li>formule pevné délky jsou generovány výběrem m klauzulí</li>
<li>každá klauzule délky k je uniformně náhodně generována z množiny všech klauzulí</li>
</ul>
<h1 id=optimalizační-problém-s-podmínkami-cop>Optimalizační problém s podmínkami (COP)</h1>
<p>Problém splňování podmínek (X, D, C)</p>
<ul>
<li>proměnné X</li>
<li>domény D</li>
<li>omezení C</li>
</ul>
<p>Základní definice:</p>
<ul>
<li>Optimalizační problém s podmínkami (constraint optimization problem)</li>
</ul>
<h2 id=cop-operační-výzkum>COP: operační výzkum</h2>
<ul>
<li>Pevné (hard, required) omezení C_h</li>
<li>Měkké (soft) omezení C_s</li>
</ul>
<p>Optimalizační problém s podmínkami (COP): (X, D, Ch, Cs)</p>
<h2 id=použití-měkkých-omezení>Použití měkkých omezení</h2>
<ul>
<li>Problémy optimalizační, příliš podmíněné, špatně definované problémy</li>
<li>Fuzzy preference, pravděpodobnosti, ceny, váhy, úrovně požadavků</li>
<li>Příliš podmíněné problémy: řešení CSP neexistuje</li>
<li>Problémy s nejistotou</li>
<li>Špatně definované problémy: není zřejmé, která omezení definují CSP</li>
</ul>
<h2 id=přístupy-pro-měkká-omezení>Přístupy pro měkká omezení</h2>
<p>Vybrané přístupy:</p>
<ul>
<li>základní: MAX-CSP, omezení s váhami, fuzzy omezení</li>
<li>zobecňující: omezení nad polookruhy (semiring-based )</li>
</ul>
<p>Rozlišení systémů na základě:</p>
<ul>
<li>omezení – rozšíření klasického omezení</li>
<li>problém – rozšíření CSP</li>
<li>úroveň splnění – jak přiřazení hodnot splňuje problém</li>
<li>řešení – které přiřazení je (optimálním) řešením</li>
<li>úroveň konzistence problému – jak je možné nejlépe splnit problém tj. jak (optimální) řešení splňuje problém</li>
</ul>
<h2 id=omezení-s-váhami>Omezení s váhami</h2>
<ul>
<li>váha/cena spojená s každým omezením</li>
<li>omezení – dvojice (c, w (c))</li>
<li>problém – trojice (V , D, C_w)</li>
<li>úroveň splnění – funkce na množině přiřazení => součet vah nesplněných omezení</li>
<li>řešení – přiřazení θ s minimální</li>
<li>úroveň konzistence – úroveň splnění řešení</li>
</ul>
<h1 id=max-csp-maximální-csp>MAX-CSP (maximální CSP)</h1>
<ul>
<li>váha je rovna jedné ⇒ maximalizace počtu splněných omezení</li>
</ul>
<h1 id=fuzzy-csp>Fuzzy CSP</h1>
<p>Fuzzy množiny: příslušnost prvku k množině zadána číslem z intervalu [0, 1]</p>
<p>Fuzzy omezení: fuzzy relace μc(d1, &mldr;, dk)∈〈0,1〉udává úroveň preference</p>
<p>Fuzzy CSP (X, D, Cf)</p>
<ul>
<li>Cf je množina fuzzy omezení</li>
<li>X uspořádaná množina proměnných</li>
</ul>
<h1 id=kombinace-a-projekce-omezení>Kombinace a projekce omezení</h1>
<p>Kombinace (+ v kolecku): bere se min z podminek</p>
<ul>
<li>c, cX, cY omezení nad Z, X, Y</li>
</ul>
<p>Projekce(sipka dolu): bere se max</p>
<ul>
<li>c, cX, cY omezení nad X, X, Y</li>
</ul>
<p>Reseni fuzzy je max z vsech moznych kombinaci podminek</p>
<h1 id=omezení-nad-polookruhy>Omezení nad polookruhy</h1>
<p>// TODO</p>
<h1 id=optimalizace--soft-omezení-algoritmy>Optimalizace & soft omezení: algoritmy</h1>
<h2 id=soft-propagace>Soft propagace</h2>
<p>Klasická propagace: eliminace nekonzistentních hodnot z domén proměnných</p>
<p>Soft propagace:</p>
<ul>
<li>propagace preferencí (cen) nad k-ticemi hodnot proměnných</li>
<li>snaha o získání realističtějších preferencí</li>
<li>výpočet realističtějších příspěvků pro cenovou funkci</li>
</ul>
<h2 id=sac-a-cop>SAC A COP</h2>
<p>//TODO</p>
<h1 id=metoda-větví-a-mezí-branchbound-bb>Metoda větví a mezí (branch&bound) BB</h1>
<p>Prohledávání stromu do hloubky:</p>
<ul>
<li>přiřazené=minulé proměnné P, nepřiřazené=budoucí proměnné F</li>
<li>omezení pouze na minulých proměnných C_P,</li>
<li>omezení na minulých i budoucích proměnných C_PF</li>
<li>omezení pouze na budoucích proměnných C_F</li>
</ul>
<p>Výpočet mezí:</p>
<ul>
<li>horní mez UB: cena nejlepšího dosud nalezeného řešení</li>
<li>dolní mez LB: dolní odhad minimální ceny pro současné částečné přiřazení</li>
</ul>
<p>Ořezávání: LB ≥ UB</p>
<ul>
<li>víme, že rozšíření současného částečného řešení už bude mít horší (vyšší) cenu LB než dosud nalezené řešení UB</li>
<li>lze proto ořezat tuto část prohledávacího prostoru</li>
<li>příklad: pokud nalezneme řešení s cenou 10 odřízneme všechny větve, které mají cenu vyšší než 9</li>
</ul>
<h2 id=metoda-větví-a-mezí-výběr-hodnoty>Metoda větví a mezí: výběr hodnoty</h2>
<ul>
<li>generický algoritmus rozšiřitelný jako implementace backtrackingu</li>
<li>možná rozšíření zejména o: pohled dopředu, výpočet dolní meze</li>
</ul>
<p>LB(~d ) vrací dolní odhad ceny pro každé částečné přiřazení ~d</p>
<ul>
<li>Optimistický výběr hodnoty</li>
</ul>
<h2 id=dolní-mez>Dolní mez</h2>
<p>Kvalita dolní meze: velmi důležitá pro efektivitu BB</p>
<p>Dolní mez lze ovlivnit pomocí:</p>
<ul>
<li>ceny minulých proměnných: vzdálenost (součet vah omezení na minulých proměnných)</li>
<li>lokální ceny budoucích proměnných vzhledem k minulým proměnným: NC*</li>
<li>lokální ceny budoucích proměnných: AC*</li>
</ul>
<h1 id=nc-algoritmus>NC∗ algoritmus</h1>
<ul>
<li>Projekce ceny hodnot (j, ∗) pro každou proměnnou j do dolní hranice LB ceny řešení</li>
<li>Smazání hodnot (j, a) převyšující (nebo rovné) horní hranici UB</li>
</ul>
</div>
</article>
<hr>
<div class=post-info>
</div>
</main>
</div>
<footer class=footer>
</footer>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script>
</div>
<script type=text/javascript src=/bundle.min.b2a4161afad463d91113a005f8f24a5efff27a6cc48754e9e93adc7bccb8a876a153a953c0b12653f3b5910e41e620da731f8184f2973058100d159c09fa8346.js integrity="sha512-sqQWGvrUY9kRE6AF+PJKXv/yemzEh1Tp6Trce8y4qHahU6lTwLEmU/O1kQ5B5iDacx+BhPKXMFgQDRWcCfqDRg=="></script>
</body>
</html>