<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="| Local space | | Model Matrix | World space | | View matrix | View space | | projection matrix | Clip space | Screen space
gluOrtho2D - create world window gluOrtho2D — define a 2D orthographic projection matrix glLoadIdentity replaces the current matrix with the identity matrix
glViewport(40,60,360,240)
Normals - describe the orientation of a surface of a geometric object at a point on that surfac normal vector - perpendicular to the surface"><meta name=keywords content><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://rand-notes.github.io/uwyo/graphics/0/><title>Midterm :: idk</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/main.7209ab6422eb371a6b685a56274cc88eff3db604665c3bdb698389c0585d4211.css><meta itemprop=name content="Midterm"><meta itemprop=description content="| Local space | | Model Matrix | World space | | View matrix | View space | | projection matrix | Clip space | Screen space
gluOrtho2D - create world window gluOrtho2D — define a 2D orthographic projection matrix glLoadIdentity replaces the current matrix with the identity matrix
glViewport(40,60,360,240)
Normals - describe the orientation of a surface of a geometric object at a point on that surfac normal vector - perpendicular to the surface"><meta itemprop=datePublished content="2021-09-02T00:00:00+00:00"><meta itemprop=dateModified content="2021-09-02T00:00:00+00:00"><meta itemprop=wordCount content="1981"><meta itemprop=image content="https://rand-notes.github.io"><meta itemprop=keywords content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rand-notes.github.io"><meta name=twitter:title content="Midterm"><meta name=twitter:description content="| Local space | | Model Matrix | World space | | View matrix | View space | | projection matrix | Clip space | Screen space
gluOrtho2D - create world window gluOrtho2D — define a 2D orthographic projection matrix glLoadIdentity replaces the current matrix with the identity matrix
glViewport(40,60,360,240)
Normals - describe the orientation of a surface of a geometric object at a point on that surfac normal vector - perpendicular to the surface"><meta property="og:title" content="Midterm"><meta property="og:description" content="| Local space | | Model Matrix | World space | | View matrix | View space | | projection matrix | Clip space | Screen space
gluOrtho2D - create world window gluOrtho2D — define a 2D orthographic projection matrix glLoadIdentity replaces the current matrix with the identity matrix
glViewport(40,60,360,240)
Normals - describe the orientation of a surface of a geometric object at a point on that surfac normal vector - perpendicular to the surface"><meta property="og:type" content="article"><meta property="og:url" content="https://rand-notes.github.io/uwyo/graphics/0/"><meta property="og:image" content="https://rand-notes.github.io"><meta property="article:section" content="uwyo"><meta property="article:published_time" content="2021-09-02T00:00:00+00:00"><meta property="article:modified_time" content="2021-09-02T00:00:00+00:00"><meta property="og:site_name" content="idk"><meta property="article:published_time" content="2021-09-02 00:00:00 +0000 UTC"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo>title</div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/posts>notes</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class="theme-toggle not-selectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=https://rand-notes.github.io/uwyo/graphics/0/>Midterm</a></h2><div class=post-content><p>| Local space
| | Model Matrix
| World space
| | View matrix
| View space
| | projection matrix
| Clip space
| Screen space</p><p>gluOrtho2D - create world window
gluOrtho2D — define a 2D orthographic projection matrix
glLoadIdentity replaces the current matrix with the identity matrix</p><p>glViewport(40,60,360,240)</p><p>Normals - describe the orientation of a surface of a geometric object at a point on that surfac
normal vector - perpendicular to the surface</p><h1 id=window-to-viewport-mapping>Window-to-Viewport Mapping</h1><p>Based on formula that produces a point (sx,sy) in the screen-window coordinates for any given point (x,y) in the world coordinates</p><h1 id=modeling-task>Modeling Task</h1><ul><li>To create and/or use Geometric objects</li><li>Space where geometric objects are described as is called the world coordinates</li></ul><h1 id=viewing-task>Viewing Task</h1><ul><li>To size and position the pictures of those geometric objects on the display</li><li>Space where the viewport displays output from mappings in screen coordinates</li></ul><p>Modelview matrix is composed of the scene transformations, M, and the camera transformations, V.</p><p>Graphic pipeline:</p><p>Modelview matrix -> projection matrix -> perspective division -> viewport matrix -> |window
coordinates|</p><h1 id=projection-transformation>Projection Transformation</h1><p>View Volume</p><ul><li>Parallel</li><li>Perspective</li><li>isometric
Types of Projection</li><li>Parallel (orthographic)</li><li>perspective
Important to Control</li><li>Projection type</li><li>Field of view and image aspect ratio</li><li>Near and far clipping planes</li></ul><h1 id=parallel-orthographic-projection>Parallel (Orthographic) projection</h1><p>No foreshortening effect</p><ul><li>Distance from camera does not matter</li><li>Objects are same size no matter what</li></ul><p>The center of projection is at infinity</p><p>Projection calculation</p><ul><li>Just choose to equal the z coordinates</li></ul><h1 id=field-of-view>Field of View</h1><ul><li>Determine how much of the world is going to be “seen”</li><li>Larger field of view = smaller object projection size</li></ul><h1 id=camera>Camera</h1><ul><li>The camera has an eye (or view reference point VRP) at some point in space</li><li>Its view volume is a portion of a pyramid, whose apex is at the eye</li><li>The straight line from a point P to the eye is called the projector of P. (All projectors of a point meet at the eye.)</li><li>The axis of the view volume is called the view plane normal, or VPN</li><li>The opening of the pyramid is set by the viewangle</li><li>Three planes are defined perpendicular to the VPN - near plane, the view plane, and the far plane</li><li>The windows have an aspect ratio which can be set in a program</li><li>OpenGL clips points of the scene lying outside the view volume (view frustum)</li><li>Points P inside the view volume are projected onto the view plane to a corresponding point P</li><li>Finally, the image formed on the view plane is mapped into the viewport, and becomes visible on the display device</li></ul><h1 id=points>Points</h1><ul><li>have position</li><li>Do not have length and direction (relative to a coordinate system)</li></ul><h1 id=vectors>Vectors</h1><ul><li><p>have length and direction</p></li><li><p>Does not have position (relative to coordinate system)</p></li><li><p>can be moved anywhere</p></li><li><p>A vector is displacement from one point to another</p></li><li><p>displacement: the moving of something from its place or position.</p></li></ul><h1 id=scalar>Scalar</h1><ul><li>size only (a number)</li></ul><h1 id=basics-of-points-and-vectors>Basics of Points and Vectors</h1><ul><li>All points and vectors are defined relative to some coordinate system.</li></ul><p>example: 2d coordinate system</p><h1 id=vector-representations>Vector Representations</h1><p>v = (1, 2, 3) is a row vector
v = (1, 2, 3)^T is a column vector</p><p>Subtracting c from a is equivalent to adding a and -c.</p><p>The magnitude (length, size) of n-vector w is written |w|.</p><p><code>|w| = sqrt(w_1^2 + w_2^2 + ...)</code></p><h1 id=opengl-routines>OpenGL Routines</h1><p>-glScaled (sx, sy, sz);
2D: sz = 1.0</p><p>-glTranslated (tx, ty, tz);
2D: tz = 0.0</p><p>-glRotated (angle, ux, uy, uz);
2D: ux = uy = 0.0; uz = 1.0</p><h1 id=transformations>Transformations</h1><p>Transformations change 2D or 3D points and vectors, or change coordinate systems</p><p>An <strong>object transformation</strong> alters the coordinates of each point on the object according to the same rule, leaving the underlying coordinate system fixed.</p><p>A <strong>coordinate transformation</strong> defines a new coordinate system in terms of the
old one, then represents all of the object’s points in this new system</p><p>A coordinate frame consists of:</p><ul><li>a point O, called the origin</li><li>and some mutually perpendicular vectors that serve as the axes of the coordinate frame</li><li>Standard Unit Vectors are Used: The unit vectors are orthogonal</li><li>A unit vector has magnitude |v| = 1</li></ul><h1 id=affine-transformations>Affine Transformations</h1><p>Successive affine transformations can be combined into a single overall affine transformation.</p><p>affine transformation is a geometric transformation that preserves lines and parallelism (but not necessarily distances and angles).</p><p>Matrix M form of the affine trans for 2D</p><pre tabindex=0><code>(Qx)  (m m m)(P) 
(Qy) =(m m m)(P)
(1 )  (0 0 1)(1)
</code></pre><p>M is post multiply
M^t is pre multiply</p><h1 id=3-d-affine-transformations>3-D Affine Transformations</h1><p>The matrix representing a transformation is now 4 x 4</p><h1 id=perspective-matrix>Perspective Matrix</h1><p>public static Matrix4x4 Perspective(fov, aspect, znear, zfar)</p><ul><li>Set glmatrix mode to GL_Projection</li><li>For perspective projection use: gluPerspective
or</li><li>glFrustrum(left, right, bottom, top, new, far);</li><li>For orthographic projection, use: glOrtho</li></ul><h1 id=setting-the-view-volume>Setting the View Volume</h1><ul><li>Define a look point as a point of particular interest in the scene, and together the
two points eye and look define VPN as eye-look</li><li>This is later normalized to become the vector n, which is central in specifying the
camera properly.</li><li>VPN points from look to eye.</li><li></li></ul><h1 id=projection-plane>Projection Plane</h1><ul><li>Projection plane called the view plane in computer graphics</li><li>Is defined by a point called view reference point (VRP) and a normal (a vector perpendicular to the plane) called view plane normal (VPN).</li></ul><h1 id=viewing-transformation>Viewing Transformation</h1><ul><li>gluLookAt fills V part of modelview matrix</li><li>Modelview Matrix: Combination of modeling matrix M and Camera transforms V</li></ul><h1 id=glulookat>gluLookAt</h1><p>gluLookAt takes the points eye and look, and the vector up</p><p>//TODO construct look at</p><h1 id=camera-with-arbitrary-orientation-and-position>Camera with Arbitrary Orientation and Position</h1><ul><li>Position is easy to describe, but orientation is difficult.</li><li>We specify orientation using the flying terms: pitch, heading, yaw, and roll.</li></ul><h1 id=flying-the-camera-through-a-scene>Flying the Camera through a Scene</h1><ul><li>The user can fly the camera through a scene interactively by pressing keys or
clicking the mouse.</li></ul><h1 id=flying-the-camera-through-a-scene-1>Flying the Camera through a Scene</h1><p>There are six degrees of freedom for adjusting a camera:</p><ul><li>it can fly in three dimensions</li><li>it can be rotated about any of three coordinate axes</li><li>We first develop the slide() function</li></ul><h1 id=polygonal-meshes>Polygonal Meshes</h1><p>A polygonal mesh is a collection of polygons (faces) that approximate the surface of
a 3D object.</p><h1 id=3d-modeling>3D Modeling</h1><p>Polygonal meshes capture the shape of complex 3D objects in simple data structures</p><ul><li>Platonic solids, the Buckyball, geodesic domes, prisms</li><li>Extruded or swept shapes, and surfaces of revolution</li><li>Solids with smoothly curved surfaces</li></ul><p>Animated Particle systems:
– Each particle responds to conditions.
– Position, a velocity, and perhaps a color, lifetime, size, degree of transparency, and shape.
– Randomly generated</p><h1 id=polygonal-meshes-1>Polygonal Meshes</h1><ul><li>Polygons are easy to represent (by a sequence of vertices) and transform</li><li>They have simple properties (a single normal vector, a well-defined inside and
outside, etc.)</li><li>They are easy to draw</li><li>Meshes are a standard way of representing 3D objects in graphics</li><li>A mesh can approximate the surface to any degree of accuracy by making the mesh finer or coarser</li></ul><p>Meshes can model both solid shapes and thin skins.</p><ul><li>The object is solid if the polygonal faces fit together to enclose space.
– the faces fit together without enclosing space</li></ul><h1 id=polygonal-meshes-in-opengl>Polygonal Meshes in OpenGL</h1><ul><li>A polygonal mesh is described by a list of polygons, along with information about the direction in which each polygon is facing.</li><li>If the mesh represents a solid, each face has an inside and an outside relative to the rest of the mesh</li><li>In such a case, the directional information is often simply the outward pointing normal vector to the plane of the face used in the shading process.</li></ul><h1 id=polygonal-meshes-normal-vector>Polygonal Meshes: Normal Vector</h1><ul><li>The normal direction to a face determines its brightness</li><li>For some objects, we associate a normal vector to each vertex of a face rather
than one vector to an entire face.</li><li>We use meshes, which represent objects with smoothly curved faces such as a sphere
or cylinder</li><li>smooth-underlying surface</li></ul><h1 id=polygonal-meshes-2>Polygonal meshes</h1><ul><li>For the smoothly curved surface of the cylinder, both vertex V1 of face F1 and vertex V2 on face F2 use the same normal n, the vector perpendicular to the underlying smooth surface.</li><li>basically: we we put e.g. hexagon around circle, and taking normals for circle from hexagon</li></ul><h1 id=defining-a-polygonal-mesh>Defining a Polygonal Mesh</h1><ul><li>A mesh consists of 3 lists: the vertices of the mesh, the outside normal at each vertex, and the faces of the mesh.</li><li>It has a square floor one unit on a side.</li></ul><h1 id=defining-a-polygonal-mesh-1>Defining a Polygonal Mesh</h1><ul><li>The vertex list reports the locations of the distinct vertices in the mesh</li><li>The list of normals reports the directions of the distinct normal vectors that occur in the model</li><li>The face list indexes into the vertex and normal lists</li><li>The list of vertices for a face begins with any vertex in the face, and then
proceeds around the face vertex by vertex until a complete circuit has been made.</li></ul><p>There are two ways to traverse a polygon:</p><ul><li>clockwise</li><li>counter-clockwise</li></ul><p>Convention: Traverse the polygon counterclockwise as seen from outside the object</p><ul><li>Using this order, if you traverse around the face by walking from vertex to vertex, the inside of the face is on your left.</li><li>Using the convention allows algorithms to distinguish with ease the front from the back of a face.</li><li>If we use an underlying smooth surface, such as a cylinder, normals are computed for that surface.</li></ul><h1 id=properties-of-meshes>Properties of Meshes</h1><ul><li>A mesh is convex if the line connecting any two interior points is entirely inside the mesh.</li><li>Exterior connecting lines are shown for non-convex objects below (step and torus).</li><li>A closed mesh represents a solid object (which encloses a volume)</li><li>A mesh is connected if there is an unbroken path along the edges of the mesh between any two vertices.</li><li>A mesh is simple if it has no holes. Example: a sphere is simple; a torus is not.</li><li>A mesh is planar if every face is a plane polygon. Triangular meshes are frequently used to enforce planarity.</li></ul><h1 id=platonic-solids>Platonic Solids</h1><p>All the faces are identical and each is a regular polygon.</p><h1 id=calculating-normals>Calculating Normals</h1><p><code>m = (V1 - V2) x (V3 - V2)</code></p><h1 id=newells-method-for-normals>Newell&rsquo;s Method for Normals</h1><ul><li>Given N vertices, define: next(i) = ni = (i+1) mod N.</li><li>Traverse the vertices for the face in counter-clockwise order from the outside</li><li>The normal given by the values on the next slide points to the outside (front) of the face</li></ul><h1 id=extruded-shapes>Extruded Shapes</h1><ul><li>A large class of shapes can be generated by extruding or sweeping a 2d shape through space.</li><li>In addition, surfaces of revolution can also be approximated by extrusion of a
polygon once we slightly broaden the definition of extrusion.</li><li>Prism: formed by sweeping the arrow along a straight line.</li></ul><h1 id=prisms>Prisms</h1><ul><li>A prism is formed by moving a regular polygon along a straight line.</li><li>When the line is perpendicular to the polygon, the prism is a right prism</li></ul><h1 id=extruded-shapes-1>Extruded Shapes</h1><ul><li><p>Base has vertices (xi, yi, 0) and top has vertices (xi, yi, H).</p></li><li><p>Each vertex (xi, yi, H) on the top is connected to corresponding vertex (xi, yi, 0) on the base</p></li><li><p>If the polygon has n sides, then</p></li><li><p>n vertical sides of the prism</p></li><li><p>a top side (cap)</p></li><li><p>a bottom side (base), or n+2 faces altogether</p></li><li><p>The normals for the prism are the face normals.</p></li><li><p>These may be obtained using the Newell method, and the normal list for the prism constructed</p></li></ul><h1 id=arrays-of-extruded-prisms>Arrays of Extruded Prisms</h1><p>OpenGL can reliably draw only convex
polygons. For non-convex prisms, stack the
parts.</p><h1 id=vertex-list-for-the-prism>Vertex List for the Prism</h1><ul><li>Suppose the prism&rsquo;s base is a polygon with N vertices (xi, yi).</li><li>We number the vertices of the base 0, . . . , N-1 and those of the cap N, . . ., 2N -1, so that an edge joins vertices i and i + N</li><li>The vertex list is then easily constructed to contain the points (xi, yi, 0) and (xi, yi, H), for i = 0, 1, &mldr;, N-1.</li></ul><h1 id=face-list-for-the-prism>Face List for the Prism</h1><p>We first make the side faces and then add the cap and base</p></div></article><hr><div class=post-info></div></main></div><footer class=footer></footer><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script></div><script type=text/javascript src=/bundle.min.c7e937cd76fb1097985d5c8ae541eb44da0ddf0ecfc093bb5e2fe6be756ac425b77825c1c7d6f19ac4c0c4d18ae466ea8bf31c3f646c557dedb72d8a31bbd7e2.js integrity="sha512-x+k3zXb7EJeYXVyK5UHrRNoN3w7PwJO7Xi/mvnVqxCW3eCXBx9bxmsTAxNGK5Gbqi/McP2RsVX3tty2KMbvX4g=="></script></body></html>