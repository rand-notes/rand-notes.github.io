<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="k-opt TODO
k-distance TODO
Ejection Chain řetězec odstranění: posloupnost přesunů zákazníka z jednoho okruhu na následující úspěšná změna: žádný vrchol není v řešení více než jednou řetězec odstranění nemusí být cyklický (stačí umístit konzistentně posledního zákazníka do posledního okruhu) postup každý řetězec odstranění zahrnuje k úrovní začínajících na okruhu 1 a končících na okruhu k vrchol je odstraněn z okruhu 1 a přesunut na okruh 2, vrchol z okruhu 2 přesunut na okruh 3, atd."><meta name=keywords content><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://rand-notes.github.io/ai/exam/><title>algos :: idk</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/main.7209ab6422eb371a6b685a56274cc88eff3db604665c3bdb698389c0585d4211.css><meta itemprop=name content="algos"><meta itemprop=description content="k-opt TODO
k-distance TODO
Ejection Chain řetězec odstranění: posloupnost přesunů zákazníka z jednoho okruhu na následující úspěšná změna: žádný vrchol není v řešení více než jednou řetězec odstranění nemusí být cyklický (stačí umístit konzistentně posledního zákazníka do posledního okruhu) postup každý řetězec odstranění zahrnuje k úrovní začínajících na okruhu 1 a končících na okruhu k vrchol je odstraněn z okruhu 1 a přesunut na okruh 2, vrchol z okruhu 2 přesunut na okruh 3, atd."><meta itemprop=wordCount content="7472"><meta itemprop=image content="https://rand-notes.github.io"><meta itemprop=keywords content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rand-notes.github.io"><meta name=twitter:title content="algos"><meta name=twitter:description content="k-opt TODO
k-distance TODO
Ejection Chain řetězec odstranění: posloupnost přesunů zákazníka z jednoho okruhu na následující úspěšná změna: žádný vrchol není v řešení více než jednou řetězec odstranění nemusí být cyklický (stačí umístit konzistentně posledního zákazníka do posledního okruhu) postup každý řetězec odstranění zahrnuje k úrovní začínajících na okruhu 1 a končících na okruhu k vrchol je odstraněn z okruhu 1 a přesunut na okruh 2, vrchol z okruhu 2 přesunut na okruh 3, atd."><meta property="og:title" content="algos"><meta property="og:description" content="k-opt TODO
k-distance TODO
Ejection Chain řetězec odstranění: posloupnost přesunů zákazníka z jednoho okruhu na následující úspěšná změna: žádný vrchol není v řešení více než jednou řetězec odstranění nemusí být cyklický (stačí umístit konzistentně posledního zákazníka do posledního okruhu) postup každý řetězec odstranění zahrnuje k úrovní začínajících na okruhu 1 a končících na okruhu k vrchol je odstraněn z okruhu 1 a přesunut na okruh 2, vrchol z okruhu 2 přesunut na okruh 3, atd."><meta property="og:type" content="article"><meta property="og:url" content="https://rand-notes.github.io/ai/exam/"><meta property="og:image" content="https://rand-notes.github.io"><meta property="article:section" content="fi"><meta property="og:site_name" content="idk"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo>title</div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/posts>notes</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class="theme-toggle not-selectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=https://rand-notes.github.io/ai/exam/>algos</a></h2><div class=post-content><h1 id=k-opt>k-opt</h1><p>TODO</p><h1 id=k-distance>k-distance</h1><p>TODO</p><h1 id=ejection-chain>Ejection Chain</h1><ul><li>řetězec odstranění: posloupnost přesunů zákazníka z jednoho okruhu na následující</li><li>úspěšná změna: žádný vrchol není v řešení více než jednou</li><li>řetězec odstranění nemusí být cyklický (stačí umístit konzistentně posledního zákazníka do posledního okruhu)</li></ul><h2 id=postup>postup</h2><ul><li>každý řetězec odstranění zahrnuje k úrovní začínajících na okruhu 1 a končících na okruhu k</li><li>vrchol je odstraněn z okruhu 1 a přesunut na okruh 2, vrchol z okruhu 2 přesunut na okruh 3, atd. až vrchol z k-1 na k, poslední vrchol z okruhu k přesunut do okruhu 1</li></ul><h1 id=cyclic-exchange>Cyclic Exchange</h1><p>prvky mají být rozděleny do skupin S = {S1,&mldr;,Sq}<br>cyklická výměna 3 prvků (3-okolí): prvek a2 ∈S2 je přesunut do S3, a3 ∈S3 je přesunut do S4, a4 ∈S4 přesunut do počáteční skupiny S2</p><h1 id=treshold-accepting>Treshold accepting</h1><p>akceptovana i horsi reseni s maximalnim zhoresenim o prahovou hodnotu Q</p><h1 id=great-deluge>Great Deluge</h1><p>algoritmus je uveden klasicky pro minimalizacni problemy tj. hladinu(level) musimem redukovat a snazime se zustat pod LEVEL;</p><h2 id=postup-1>postup:</h2><ul><li>init reseni, rychlost deste (UP), vodni hladina</li><li>generuj soused, akceptuj pokud pod level, sniz hladinu o UP a znovu</li><li>// UP je kriticky, pokud je moc vysoky - budeme prilis moc omezeni a nebudeme akceptovat reseni, pokud moc nizky - budeme akceptovan kazdou blbost -> bude trvat dlouho</li></ul><h1 id=tabu-prohledavani>Tabu Prohledavani</h1><ul><li>udrzujeme seznam poslednich zmen - tabu seznam, iterujeme a akceptujeme kazdeho vygenerovaneho souseda ktery neni v tabu seznamu</li><li>řešení horší/stejné kvality akceptováno, pokud neexistuje lepší</li><li>často kombinováno i s dalšími algoritmy</li></ul><h2 id=aspiracni-kriterium>Aspiracni kriterium</h2><p>podmínka, za které je možné realizovat i změny z tabu seznamu, např. povolení změn, které vedou k lepší hodnotě účelové funkce</p><h1 id=iterativní-lokální-prohledávání>Iterativní lokální prohledávání</h1><ul><li>Multistart local search - iniciální řešení je generováno při další iteraci náhodně</li><li>Iterativní lokální prohledávání - nalezené lokální optimum změněno a použito při dalším lokálním prohledávání</li></ul><h1 id=prohledávání-s-proměnlivým-okolím-variable-neighborhood-search-vns>Prohledávání s proměnlivým okolím, (variable neighborhood search, VNS)</h1><p>myslenka je takova ze misto abych porad prohazoval 1 predmet, tak muzu prohodit 2, 3 nebo vice.</p><h1 id=zlepšující-prohledávání-s-proměnlivým-okolím-variable-neighborhood-descent-algorithm-vnd>Zlepšující prohledávání s proměnlivým okolím (variable neighborhood descent algorithm, VND)</h1><p>VND je deterministická verze VNS</p><h2 id=postup-2>postup</h2><ul><li>zaciname na nejmensim moznem okoli a postupujeme k maximalnimu moznemu okoli</li><li>pokud najdeme lepsiho souseda jdeme zpatky na zacatek</li><li>pokud ne rozsirime okoli</li><li>pr. rozvrh - zkusime prohodit 2 predmety, pokud nepomuze zkusime prohodit 3, pokracujeme do MAX. pokud najdeme vhodneho souseda zacine od znovu a opet to stejny</li></ul><h1 id=řízené-lokální-prohledávání---guided-local-search-gls>Řízené lokální prohledávání - guided local search, GLS</h1><ul><li>Opakovaná lokální prohledávání s upravenou účelovou funkcí</li><li>nova ucelova fce: f&rsquo;(s) = f(s) + \lambda \sum p_i I_i(s)</li><li>Každé řešení s ∈S má množinu m charakteristik i s cenou c_i</li><li>I_i (s) = 1 pokud s ma charakteristiku i jinak 0</li><li>snaha o prohledávání částí stav. prostoru s nižší cenou charakteristik</li><li>př. problém obchodního cestujícího: zda je hrana (a,b) v řešení, cenu určuje délka hrany (vzdálenost měst)</li><li>penalizace pi : význam charakteristiky (vysokou penalizaci nechceme)</li></ul><h2 id=charakteristika>Charakteristika</h2><ul><li>Charakteristika i s nejvyšším hodnotou u_i(s) = I_i (s) = c_i / (1 + p_i)</li><li>chceme se příště vyhnout charakteristikám s vysokou cenou ci</li><li>charakteristiky použité v řešení penalizovány pro podporu diversifikace</li></ul><h2 id=intensifikace>Intensifikace</h2><p>GLS prohledává stavový prostor s nižšími cenami ci</p><h2 id=diversifikace>Diversifikace</h2><p>GLS penalizuje charakteristiky použité ve vygenerovaném lokálním optimu, abychom se jim vyhnuli</p><p>Příklad: TSP a GLS</p><h1 id=metaheuristiky-s-populacemi>Metaheuristiky s populacemi</h1><ul><li>algoritmy využívající evoluci</li><li>algoritmy s pameti (blackboard)</li></ul><p>Společné koncepty: generování počáteční populace</p><ul><li>Náhodné generování</li><li>Sekvenční diversifikace -</li><li>Paralelní diversifikace - řešení generována nezávisle paralelně se snahou o celkovou maximální odlišnost řešení v populaci</li><li>Heuristická inicializace - jednotlivá řešení generována libovolnými heuristickými algoritmy</li></ul><p>Společné koncepty: podmínky ukončení</p><ul><li>Statická procedura - pevný počet iterací</li><li>Adaptivní procedura - pevný počet iterací bez zlepšení</li></ul><p>Základní koncepty evolučních algoritmů:</p><ul><li>Reprezentace<ul><li>populace</li><li>chromozom/jedinec</li><li>gen</li><li>alely</li></ul></li><li>Vhodnost (fitness) - používaný termín pro účelovou funkci</li><li>Strategie vyberu - rodičů (řešení) pro vytváření další populace</li><li>Strategie reprodukce - křížení a mutace: operace vytvářející nové jedince (potomky)</li><li>Strategie nahrady - výběr jedinců do nové populace</li></ul><h1 id=evoluční-algoritmy>Evoluční algoritmy</h1><ul><li>Genetické algoritmy</li><li>Evoluční strategie</li><li>Evoluční programování - spojitá optimalizace</li><li>Genetické programování - jedinci jsou programy</li></ul><h1 id=genetické-algoritmy>Genetické algoritmy</h1><ul><li>Typicky použití operátoru křížení nad dvěma řešeními</li><li>Mutace využívána pro zlepšení diversifikace</li><li>Pevna pravdepodobnsot mutace p_m krizeni p_c</li><li>Náhrada bývá generační: rodiče systematicky nahrazeni potomky</li></ul><h1 id=evoluční-strategie-es>Evoluční strategie (ES)</h1><ul><li>Většinou pro: spojité optimalizace, vektory reálných hodnot</li><li>Křížení využito zřídka ⇐ i pro problémy, kde nemáme vhodné křížení</li><li>Obvykle: náhrada nejlepšími jedinci (elitismu)</li><li>Populace rodičů velikosti μ, populace potomků velikosti λ ≥ μ</li></ul><p>nahrady:</p><ul><li>(1 + 1)-ES: jednoduchá verze, 1 rodič nahrazen 1 potomkem</li><li>(μ + λ)-ES: opakuj λ-krát: (náhodný výběr rodiče, vygenerován potomek); seřazení μ rodičů a λ potomků dle vhodnosti, náhrada nejlepšími</li><li>(μ,λ)-ES: pro novou populaci se vybírá jen mezi λ potomky</li></ul><h1 id=výběr-ruletovým-kolem>Výběr ruletovým kolem</h1><ul><li>nejpoužívanější strategie výběru</li><li>fi vhodnost jedince i v populaci</li><li>pravděpodobnost výběru jedince dána jako p_i = f_i / \sum f_i f_j</li><li>analogie: ruletové kolo s díly pro všechny jedince v populaci; velikost dílu ruletového kola pro jedince odpovídá pi</li><li>Problémy: příliš velká snaha vybírat kvalitní jedince ⇒ předčasná konvergence</li></ul><h1 id=pravděpodobnostní-univerzální-vzorkování>Pravděpodobnostní univerzální vzorkování</h1><p>řeší problémy rulet.kola</p><ul><li>u ruletového kola dáme μ rovnoměrně rozložených ukazatelů</li><li>jedno otočení ruletového kola vybírá μ jedinců</li></ul><h1 id=turnajový-výběr-výběr-rankováním>Turnajový výběr, výběr rankováním</h1><ul><li>náhodný výběr k jedinců</li><li>turnaj: z těchto k jedinců je výbrán nejlepší jedinec</li><li>pro výběr μ jedinců aplikujeme turnaj μ-krát</li></ul><h1 id=výběr-rankováním-rank-based-selection>Výběr rankováním (rank-based selection)</h1><ul><li>pro každého jedince spočítán rank a dle něj jsou vybíráni jedinci</li><li>rank může např. škálovát linerárně se závislostí na snaze o výběr nejlepšího jedince</li><li>rank použit pro výpočet pravděpodobnosti a aplikován stejně jako u ruletového kola</li></ul><h1 id=mutace>Mutace</h1><ul><li>operátor mutace mění jedince v populaci a způsobí jeho malou změnu</li><li>pravděpodobnost mutace genu pm ∈[0.001,0.01]</li><li>př. inicializace pm na 1/k, kde k je počet genů (rozhodovacích proměnných), tj. v průměru zmutovaná 1 proměnná</li></ul><p><strong>Mutace v binární reprezentaci</strong> - prohození (flip) hodnoty binární proměnné
<strong>Mutace v diskrétní reprezentaci</strong> - změna hodnoty prvku za jinou hodnotu v abecedě
<strong>Mutace v permutacích</strong> - vložení, výměna, inverze hodnot(y)</p><h1 id=křížení>Křížení</h1><ul><li>binární (někdy n-ární) operátor</li><li>cil: zdědit vlastnosti rodičů potomkem</li><li>pravděpodobnost křížení rodičů pc ∈[0,1], běžně pc ∈[0.45,0.95]</li></ul><h2 id=linerární-reprezentace-vyjma-permutací>Linerární reprezentace (vyjma permutací)</h2><p><strong>1-bodové křížení (1-point crossover)</strong> - podle vybrané pozice k v potomcích prohozeny hodnoty dvou rodičů
<strong>2-bodové (a n-bodové) křížení</strong> - vybrány dvě (n) pozice a provedeno prohození hodnot
<strong>uniformní křížení (uniform crossover)</strong></p><ul><li>jedinci kombinováni bez ohledu na velikost segmentů;</li><li>každý gen potomka náhodně vybrán z rodiče;</li><li>každý rodič rovnoměrně přispívá ke generování potomků stejně</li></ul><h2 id=reprezentace-permutacemi>Reprezentace permutacemi</h2><p>křížení je složitější, jedince nelze takto jednoduše kombinovat, protože každá alela (hodnota) se musí výskytnout v jedinci právě jednou (používány různé formy mapování)</p><p><strong>Křížení dané pořadím (Order crossover, OX)</strong></p><ul><li>vybrány náhodně dva body křížení</li><li>z rodiče 1 hodnoty mezi nimi zkopírovány na stejné pozice v potomkovi</li><li>z rodiče 2 začneme od druhého bodu křížení vybírat prvky, které již nebyly vybrány z rodiče 1, a dávame je do potomka od 2. bodu křížení</li></ul><h1 id=strategie-náhrady>Strategie náhrady</h1><p>Vybíráme mezi rodiči a potomky další populaci</p><h2 id=extrémní-strategie-náhrady-nepříliš-používané>Extrémní strategie náhrady (nepříliš používané)</h2><ul><li>úplná náhrada (generational replacement)<ul><li>potomky bude nahrazena systematicky celá populace rodičů</li><li>ztrácíme i nejlepší jedince</li></ul></li><li>náhrada jednotlivce (steady-state replacement)<ul><li>bude vytvořen pouze jediný potomek, který nahradí např. nejhoršího jedince populace</li><li>tj. degradace genetických algoritmů, otázka smyslu práce s populací</li></ul></li></ul><h2 id=používány-strategie-na-pomezí-mezi-těmito-krajními-přístupy>Používány strategie na pomezí mezi těmito krajními přístupy</h2><ul><li>náhrada pevného množství jedinců<ul><li>pro náhradu vybíráno λ jedinců populace při velikosti populace μ</li><li><code>1 &lt; λ μ</code></li></ul></li><li>elitářský model<ul><li>výběr nejlepších jedinců mezi rodiči a potomky</li><li>rychlá avšak předčasná konvergence</li></ul></li></ul><h1 id=inteligence-hejna-swarm-intelligence>Inteligence hejna (swarm intelligence)</h1><p>Algoritmy inspirované skupinových chováním druhů jako jsou mravenci, včely, vosy, termiti, ryby nebo ptáci<br>Původ v sociální chování těchto druhů při hledání potravy<br>Základní charakteristika algoritmů:</p><ul><li>jedinci jsou jednodušší nesofistikovaní agenti</li><li>jedinci kooperují nepřímo pomocí média</li></ul><h1 id=optimalizace-mravenčí-kolonie-ant-colony-optimization-aco>Optimalizace mravenčí kolonie (Ant Colony Optimization, ACO)</h1><ul><li>Myšlenky inspirující algoritmus</li><li>mravenčí kolonie schopna najít nejkratší cestu mezi dvěma body</li><li>mravenci během cesty nechávají na zemi chemickou stopu (feromony)</li><li>feromony vedou mravence v cíli</li><li>feromony se postupně vypařují</li><li>Algoritmus</li><li>inicializace feromonů</li><li>iterace: konstrukce řešení mravencem, aktualizace feromonů</li></ul><p>Feromonové informace:</p><ul><li>τ typicky jako matice/vektor hodnot obsahující feromonovou stopu</li><li>př. matice jako reprezentace grafu obsahuje feromony na hranách
Vypařování feromonů:</li><li>τ_ij = (1 −ρ)τ_ij realizuje pro každé i,j vypařování feromonů</li><li>ρ ∈[0,1]
Zesilovani feromonu:</li><li>online aktualizace</li><li>τij aktualizováno v každém kroku</li><li>online pozdržená aktualizace</li><li>τ aktualizováno po nalezení úplného řešení jedním mravencem</li><li>př. čím lepší řešení, tím více feromony zesíleny</li><li>off-line aktualizace</li><li>τ aktualizováno po nalezení úplného řešení všemi mravenci</li><li>nejpopulárnější přístup</li><li>př. aktualizace feromonů dle kvality (feromony aktualizovány dle nejlepšího (nebo několika nejlepších) řešení)</li></ul><h1 id=plánování-v-kostce-klasické-plánování>Plánování v kostce: klasické plánování</h1><p>Vstup:</p><ul><li>počáteční (současný) stav světa</li><li>popis akcí schopných měnit stav světa</li><li>požadovaný stav světa
Vystup:</li><li>seznam akcí (plán)</li></ul><p>klasické plánování:</p><ul><li>Stavové proměnné</li><li>Počáteční stav</li><li>Cílový stav</li><li>Akce a.k.a. operátory</li></ul><p>STRIPS plánování: Všechny proměnné mají doménu {T,F}</p><h1 id=plánování-a-rozvrhování>Plánování a rozvrhování</h1><p>Plánování (planning)</p><ul><li>rozhodování, jaké akce jsou potřeba pro dosazeni danych cilu</li><li>složitost: často horší než NP-úplné</li></ul><p>Rozvrhování (scheduling)</p><ul><li>rozhodování, jak zpracovat dané akce použitím omezených zdrojů a času</li><li>složitost: typicky NP-úplné</li></ul><p>Plánování: rozhodnutelnost</p><ul><li>PlanSAT: Existuje plán, který řeší zadaný plánovací problém?</li><li>BoundedPlanSAT: Existuje plán délky k nebo kratší, který řeší zadaný plánovací problém?</li></ul><p>Oba problémy rozhodnutelné pro klasické plánování <code>&lt;=</code> pocet stavu je konecny</p><p>Přidání funkčních symbolů do jazyka:</p><ul><li>počet stavů je nekonečný</li><li>PlanSAT částečně rozhodnutelný</li><li>existuje algoritmus, který skončí pro řešitelné problémy</li><li>pro neřešitelné problémy nemusí skončit</li><li>BoundedPlanSAT zůstává rozhodnutelný</li></ul><h2 id=formalizace-konceptuální-model>Formalizace: konceptuální model</h2><p>Plánování se zabývá volbou a organizací akcí, které mění stav systému</p><p>Systém Σ modelující stavy a přechody:</p><ul><li>množina stavů S (rekurzivně spočetná)</li><li>množina akcí A (rekurzivně spočetná)</li><li>plánovač kontroluje akce!</li><li>no-op (prázdná akce)</li><li>množina událostí E (rekurzivě spočetná)</li><li>událost mimo kontrolu plánovače!</li><li>neutrální událost ε</li><li>přechodová funkce γ : S ×A ×E →P(S)</li><li>někdy se akce a události aplikují odděleně γ : S ×(A ∪E) → P(S)</li></ul><h2 id=cíle-plánování>Cíle plánování</h2><p>Cílem plánování je zjistit, jaké akce a na které stavy se mají aplikovat, abychom za dané situace dosáhli požadovaných cílů</p><p>Co je cílem plánování?</p><ul><li><p>cílový stav nebo množina cílových stavů</p></li><li><p>splnění dané podmínky nad posloupností stavů, přes které systém prochazi</p></li><li><p>např. stavy, kterým se vyhnout, nebo stavy, které se musí navštívit</p></li><li><p>optimalizace dané objektivní funkce nad posloupností stavů</p></li><li><p>např. maximum nebo součet ohodnocení stavů</p></li><li><p>Plánovač generuje plány</p></li><li><p>Řadič se stará o jejich realizaci</p></li><li><ul><li>pro daný stav určí akci k provedení</li></ul></li><li><ul><li>pozorování převádějí reálný stav na modelovaný stav</li></ul></li><li><p>Dynamické plánování - umožňuje přeplánování na základě aktuálního stavu provádění</p></li></ul><h1 id=strips-plánování>STRIPS plánování</h1><p>Pracujeme s deterministickým, statickým, konečným a plně pozorovatelným stavovým modelem s omezenými cíli a implicitním časem Σ = (S,A,γ).</p><p>Plánovací problém P = (Σ,s0,g):</p><ul><li>s0 je počáteční stav</li><li>g charakterizuje cílové stavy</li></ul><p>Řešením plánovacího problému P je posloupnost akcí 〈a1,a2,&mldr;,ak></p><h1 id=klasické-plánování-množinová-reprezentace>Klasické plánování: množinová reprezentace</h1><p>Stav systému je popsán množinou výroků</p><p>Každá akce je syntaktický výraz specifikující:</p><ul><li>jaké výroky musí patřit do stavu, aby na něj byla akce aplikovatelná</li><li>jaké výroky akce přidá a jaké výroky smaže, aby vytvořila nový stav</li></ul><p>Klasická reprezentace zobecňuje množinovou reprezentaci směrem k predikátové logice:</p><ul><li>stavy jsou množiny logických atomů (místo výroků u množ.rep.), které jsou v dané interpretaci buď pravda nebo nepravda</li><li>akce jsou reprezentovány plánovacími operátory, které mění pravdivostní hodnotu těchto atomů</li></ul><p>Přesněji:</p><ul><li>L (jazyk) je konečná množina predikátových symbolů a konstant (nemáme funkce!)</li><li>atom je predikátový symbol s argumenty napr. on(c3, c1)</li><li>můžeme používat proměnné napr. on(x, y)</li></ul><p>Reprezentace stavů:</p><ul><li>Stav je množina instanciovaných atomů (bez proměnných).</li><li>Pravdivostní hodnota některých atomů se mění<ul><li>flexibilní atomy (fluent) napr. at(r1, loc1)</li></ul></li><li>Některé atomy nemění svoji pravdivostní hodnotu s různými stavy<ul><li>neměnné atomy (rigid) napr. adjacent(loc1,loc2)</li></ul></li></ul><p>Předpoklad uzavřeného světa (closed world assuption): atom, který není ve stavu explicitně uveden, neplatí</p><p>Plánovací operátory
Operátor o je trojice: (name(o), precond(o), effects(o))</p><ul><li>name(o): jméno operátoru ve tvaru n(x1,&mldr;,xk)</li><li>n je identifikator</li><li>x1 az xk jsou argumenty</li><li>precond(o): předpoklady - literály, které musí být splnitelné, aby šlo operátor použít</li><li>effects(o): důsledky - literály, které se stanou pravdivými aplikací operátoru</li></ul><h2 id=akce>Akce</h2><p>Akce jsou plně instanciované operátory - za proměnné jsou dosazeny konstanty</p><p>Notace:</p><ul><li>S+ = {pozitivní atomy v S}</li><li>S− = {atomy, jejichž negace je v S}</li></ul><h2 id=planovaci-domena>Planovaci domena</h2><p>Nechť L je jazyk a O je množina operátorů.<br>Plánovací doména Σ nad jazykem L a s operátory O je trojice (S,A,γ):</p><ul><li>stavy S ⊆ P({všechny instanciované atomy nad L})</li><li>akce A = {všechny instanciované operátory z O nad L}</li><li>přechodová funkce γ:<ul><li>γ(s,a) = (s −effects−(a)) ∪effects+(a), je-li a použitelná na s</li></ul></li></ul><h2 id=plánovací-problém>Plánovací problém</h2><p>Plánovací problém P je trojice (Σ,s0,g):</p><ul><li>Σ = (S,A,γ) je plánovací doména</li><li>s0 je počáteční stav, s0 ∈S</li><li>g ⊆L je množina instanciovaných literálů</li></ul><p>Zápis plánovacího problému je trojice (O,s0,g)
Plán π je posloupnost akcí 〈a1,a2,&mldr;,ak
Plán π je řešením P, právě když γ(s0,π) splňuje g</p><h2 id=4-lec>4 lec</h2><h1 id=plánování-se-stavy>Plánování se stavy</h1><p>Prohledávaný prostor odpovídá stavovému prostoru plánovacího problému</p><ul><li>uzly odpovídají stavům</li><li>hrany odpovídají stavovým přechodům pomocí akcí</li><li>cílem je najít cestu mezi počátečním stavem a některým koncovým stavem</li></ul><p>Typy prohledavani:</p><ul><li>dopředné (forward search)</li><li>zpětné (backward search) (liftovana verze, STRIPS)</li><li>problémově závislé (svět kostek)</li></ul><h1 id=dopředné-plánování>Dopředné plánování</h1><p>Začínáme v počátečním stavu a jdeme k některému cílovému stavu</p><p>Je potřeba umět:</p><ul><li>rozhodnout, zda je daný stav cílový nebo ne</li><li>najít množinu akcí aplikovatelných na daný stav</li><li>vypočítat stav, do kterého se dostaneme aplikací akce</li></ul><h2 id=postup-3>Postup</h2><ul><li><ol><li>prazdny plan P a pocatecni stav</li></ol></li><li><ol start=2><li>pokud splnujeme g vratime plan P jinak iterujeme</li></ol></li><li>do E si ulozime vsechny akce ktere splnuji preconds</li><li>z E deterministicky vybereme jednu akci A</li><li>aplikuje A a ulozime ji do planu P</li><li>opakujeme od 2</li></ul><h2 id=vlastnosti>Vlastnosti</h2><ul><li>Procedura dopředného plánování je korektní (pokud vrátí nějaký plán, potom je řešením)</li><li>Procedura dopředného plánování je úplná</li><li>pokud existuje plán potom ho alespoň jedna z nedeterministických větví najde</li><li>indukcí podle délky plánu</li><li>v každém kroku má algoritmus šanci zvolit správnou akci (pokud v přechozích krocích volil akce z plánu)</li></ul><h1 id=deterministické-implementace>Deterministické implementace</h1><p>Algoritmus dopředného prohledávání můžeme implementovat deterministicky:</p><ul><li>prohledávání do šířky (korektní, úplné, ale paměťově náročné)</li><li>prohledávání do hloubky (korektní, úplnost lze zajistit kontrolou cyklů)</li><li>A* algoritmus (nejčastěji používaný přístup)</li></ul><h2 id=větvení>Větvení</h2><p>Vysoký větvící faktor: počet možností k výběru - to vadí u determinismu, který může ztrácet čas zkoušením irelevantních akcí</p><p>Řešení:</p><ul><li>heuristika doporučující výběr akce</li><li>ořezání prohledávacího prostoru</li></ul><h1 id=zpětné-plánování>Zpětné plánování</h1><p>Začínáme s cílem (pozor to není stav, ale reprezentace množiny stavů!) a jdeme přes podcíle k počátečnímu stavu</p><p>Je potřeba umět:</p><ul><li>zjistit, zda daný stav odpovídá cíli</li><li>pro daný cíl najít relevantní akce</li><li>vypočítat podcíl umožňující aplikovat danou akci</li></ul><blockquote><p>myslenka je takova, ze relevantni akce obsahuji cil nebo jeho casti v efektech</p></blockquote><p>akce je relevantni pro cil g prave kdyz:</p><ul><li>akce přispívá do g: g ∩ effects(a) != ∅</li><li>efekty akce nejsou v konfliktu s g:</li><li>g− ∩ effects+ = ∅</li><li>g+ ∩ effects- = ∅</li></ul><p>Regresní (zpětná) množina cíle g pro (relevantní) akci a: γ−1(g,a) = (g − effects(a)) ∪ precond(a)</p><h2 id=postup-4>Postup</h2><ul><li><ol><li>prazdny plan P</li></ol></li><li><ol start=2><li>vrat plan pokud s0 splnuje g jinak iteruj</li></ol></li><li>vyber akci a pro kterou je definovano γ−1(g,a)</li><li>nedeterministicky vyber akci a, aplikuj g = γ−1(g,a) a pridej a do planu P</li></ul><h2 id=vlastnosti-1>Vlastnosti</h2><ul><li>Procedura zpětného plánování je korektní a úplná</li><li>Můžeme ji implementovat deterministicky (pro úplnost potřebujeme detekci cyklů)</li></ul><h2 id=větvení-1>Větvení</h2><ul><li>může být menší než u dopředného plánování (zacílení)</li><li>pořád ale zbytečně velké</li><li>Chceme-li, aby byl robot v pozici loc51, do které existují cesty z loc1, . . . , loc50, dostaneme 50 možných podcílů. Nám je ale pro splnění cíle jedno, odkud robot příjel!</li><li>Částečné instanciování akcí (místo úplného) dále zmenší velikost větvení, tzv liftování (lifting).</li></ul><h2 id=zpětné-plánování---liftovaná-verze>Zpětné plánování - Liftovaná verze</h2><ul><li>o je kopie operátoru s přejmenovanými (=novými) proměnnými</li><li>napr. misto move(1,2), &mldr;, move(1, n), udelame move(1, l)</li><li>MGU = největší společný unifikátor, tj. nejobecnější substituce atomů</li><li>použití volných proměnných zmenšuje větvení, ale komplikuje detekci cyklů</li></ul><h2 id=postup-5>Postup</h2><ul><li><ol><li>prazdny plan P</li></ol></li><li><ol start=2><li>pokud s0 splnuje g vrat P jinak iterace</li></ol></li><li>A = {(o | θ) - substituce θ je MGU atomu v g a atomu v effects(o) a γ−1(θ(g),θ(o)) je definováno)</li><li>nedeterministicky vyber z A</li><li>P = spojení θ(o) a θ(P)</li><li>g = γ−1(θ(g),θ(o))</li></ul><p>TODO ^</p><h1 id=strips>STRIPS</h1><p>Dosud probrané plánovací algoritmy sdílejí stejný problém – jak zlepšit efektivitu redukcí prohledávacího prostoru</p><p>STRIPS algoritmus redukuje prohledávaný prostor zpětného plánování, a to takto:</p><ul><li>z podcílů řeší vždy jen část odpovídající předpokladům poslední přidané akce:</li><li>tj. místo γ−1(s,a) se jako nový cíl použije precond(a)</li><li>vede k neúplnosti algoritmu</li><li>pokud aktuální stav splňuje všechny předpoklady operátoru, daný operátor se použije a tento závazek nebude rušen při backtrackingu</li></ul><h1 id=sussmanova-anomálie>Sussmanova anomálie</h1><p>Pravděpodobně nejznámější problém, který STRIPS neumí efektivně řešit (najde pouze redundantní plány)</p><p>mame kostky: s0: acb a g: cba -> odebereme b z vrchu -> v cili ma byt b na c, takze b ktere jsme odebrali dame zpet na c. tim ale nikdy
nedosahneme toho aby a bylo navrchu</p><p>reseni:</p><ul><li>prolínání plánů</li><li>plánování v prostoru plánů</li><li>použití doménově závislé informace</li><li>Kdy má problém ve světě kostek řešení?</li><li>v cíli nesmí být kostky, které nejsou v počátečním stavu</li><li>kostka nesmí najednou stát na dvou jiných kostkách</li></ul><h1 id=plánování-v-prostoru-plánů>Plánování v prostoru plánů</h1><h2 id=overview-pro-planovani-se-stavovym-prostorem>Overview pro planovani se stavovym prostorem</h2><p>Prakticky celou dobu pracujeme s castecnym planem. (A, <code>&lt;</code>, B, L),</p><ul><li>A jsou operatory</li><li><code>&lt;</code> je usporadani, tzn. nemuzu polozit kostku kdyz jsem ji nevzal, takze usporadam akce take, put</li><li>B, mnozina vazeb, tzn auto a patri do domeny aut A, a \in A</li><li>L je mnozina kauzalnich vztahu, tzv kdyz auto nekam prijede, tak musi rovnou nalozit, nedava smysl aby prijelo a hned odjelo, takze vazba mezi
move a load</li></ul><p>Otevreny cil je predpoklad nejakeho operatoru ktery nevime jak splnit; potrebuju splnit vsechny otevrene cile.
Hrozba je akce ktera muze porusit kauzalni vazbu.
Resici Plan je castecny plan ktery je cil.</p><h2 id=planovani>planovani</h2><p>Princip podobný zpětnému plánování ve stavovém prostoru</p><ul><li>začínáme z „prázdného plánu” obsahujícího popis počátečního stavu a cíle</li><li>přidáváme další akce, které plní dosud nesplněné (otevřené) cíle</li><li>případně přidáváme vazby mezi již přítomnými akcemi</li></ul><p>Na plánování se můžeme dívat jako na opravování kazů v částečném plánu:</p><ul><li>přecházíme od jednoho částečného plánu k dalšímu, dokud nenajdeme úplný plán</li></ul><p>Možné úpravy plánu:</p><ul><li>přidání akce</li><li>svázání proměnných</li><li>přidání podmínky uspořádání</li><li>přidání kauzální (příčinné) vazby</li></ul><p>Počáteční stav i cíl zakódujeme jako speciální akce, které jsou v prvotním částečném plánu:</p><ul><li>akce a0 reprezentuje počáteční stav tak, že nemá žádné předpoklady a počáteční stav je zakódován jako efekt;</li><li>akce a∞ reprezentuje cíl, který je zakódován jako předpoklad, efekt akce je prázdný; tato akce je za všemi ostatními akcemi</li></ul><p>Plánování bude založeno na odstraňování kazů (flaws) v částečném plánu:</p><ul><li>budeme přecházet od jednoho částečného plánu k dalšímu dokud nenajdeme řešící plán</li></ul><h2 id=uzly-jsou-plány>Uzly jsou plány</h2><p>Uzly prohledávaného prostoru jsou tvořeny částečnými plány</p><p>Částečný plán Π je čtveřice <code>(A,&lt;,B,L)</code>, kde:</p><ul><li>A je množina částečně instanciovaných plánovacích operátorů {a1,&mldr;,ak}</li><li><code>&lt;</code> je částečné uspořádání na A (ai <code>&lt;</code> aj)</li><li>B je množina vazeb tvaru x = y,x != y nebo x ∈ Di</li><li>L je množina kauzálních vztahů tvaru (ai p→ aj)</li><li>ai ,aj jsou akce uspořádané ai <code>&lt;</code> aj</li><li>p je výraz, který je efektem ai a předpokladem a</li><li>v B jsou vazby svazující příslušné proměnné v p</li></ul><h2 id=otevřený-cíl>Otevřený cíl</h2><p>Otevřený cíl (open goal) je kazem plánu</p><p>Jedná se o předpoklad p nějakého operátoru b, o kterém zatím nebylo rozhodnuto, jak ho splnit (neexistuje kauzální vazba ai p→ b)</p><p>Odstranění otevřeného cíle p akce b:</p><ul><li>najdi operátor a (buď již přítomný v plánu nebo nový), který lze použít na splnění p (má p mezi efekty a může být před b)</li><li>svaž proměnné</li><li>vytvoř kauzální vazbu</li></ul><h2 id=hrozba>Hrozba</h2><p>Hrozba (threat) je dalším kazem plánu</p><p>Jedná se o akci, která může porušit kauzální vazbu:</p><ul><li>přesněji, je-li ai p→ aj kauzální vazba a akce b ma efekt unifikovatelný s negací p a může se nacházet mezi ai a aj, potom je b hrozbou</li></ul><p>Odstranění hrozby lze udělat třemi způsoby:</p><ul><li>uspořádání b před ai</li><li>uspořádáním b za aj</li><li>navázáním proměnných v b tak, že neruší platnost p</li></ul><h2 id=řešící-plán>Řešící plán</h2><p>Částečný plán <code>Π = (A,&lt;,B,L)</code> je řešícím plánem pro problém P = (Σ,s0,g), pokud:</p><ul><li>částečné uspořádání <code>&lt;</code> a vazby B jsou globálně konzistentní</li><li>libovolná lineárně uspořádaná posloupnost plně instanciovaných akcí A splňující <code>&lt;</code> a vazby B vede z s0 do stavu splňujícího g</li></ul><p>Definice nám bohužel přímo nedává výpočtovou proceduru, jak ověřit, zda je plán řešící!</p><h1 id=algoritmus-plánování-v-prostoru-plánů-psp>Algoritmus plánování v prostoru plánů (PSP)</h1><p>postup:</p><ul><li>vstupem je plan P</li><li>kazy = otevrene cile P + hrozby P</li><li>pokud nejsou zadne kazy pak vratime P</li><li>vybereme libovolny kaz z P</li><li>zjemnění Z je mnozina moznosti jak odstranit kaz</li><li>nedeterministicky vybereme p \in Z</li><li>P&rsquo; = aplikujeme p</li><li>vratime PSP(P')</li></ul><p>Determinismus:</p><ul><li>volba kazu je deterministická - musí se odstranit všechny kazy</li><li>volba zjemnění je nedeterministická - v případě neúspěchu se zkouší další alternativa</li></ul><h2 id=podrobnosti-k-algoritmu-psp>Podrobnosti k algoritmu PSP</h2><ul><li><p>Otevřené cíle lze efektivně zjistit udržováním agendy předpokladů akcí</p></li><li><p>přidání kauzální vazby pro p vyřadí p z agendy</p></li><li><p>Všechny hrozby lze najít prozkoumáním všech trojic akcí nebo inkrementálně</p></li><li><p>po přidání akce se zjistí, komu je hrozbou</p></li><li><p>a po přidání kauzální vazby se ověří její hrozby</p></li><li><p>Pro odstranění otevřených cílů a hrozeb se používají pouze konzistentní zjemnění plánu</p></li><li><p>konzistence uspořádání buď detekcí cyklů nebo lépe udržováním tranzitivního uzávěru</p></li><li><p>konzistence vztahů B</p></li><li><p>pokud není negace, lze rychle například pomocí hranové konzistence</p></li><li><p>je-li přítomna negace, jedná se o NP-úplný problém</p></li></ul><h2 id=vlastnosti-psp>Vlastnosti PSP</h2><ul><li>Algoritmus PSP je korekní a úplný</li><li>Pozor na deterministickou implementaci</li><li>prostor plánů není konečný</li><li>úplná deterministická procedura musí garantovat prohledání všech plánů dané délky</li></ul><h1 id=algoritmus-pop>Algoritmus PoP</h1><ul><li>PoP je konkrétní (a populární) instance algoritmu PSP</li><li>agenda je množina dvojic (a,p), kde p je otevřený předpoklad akce a</li><li>nejprve hledá akci ai pro pokrytí nějakého p z agendy</li><li>ve druhé fázi řeší všechny hrozby, které vznikly přidáním akce ai , resp. kauzální vazby s ai</li></ul><h2 id=postup-6>Postup</h2><ul><li>PoP(P, agenda) , kde <code>P = (A, &lt;, B, L)</code></li><li>pokud je agenda prazda vrat P, jinak vyber libovolny par (a_j, p) a smaz ho z agenda</li><li>relevant = pokry_predpoklad(p, P)</li><li>nedeterministicky vyber akci ai ∈ relevant;</li><li>L = L ∪{〈ai p→ aj 〉};</li><li>aktualizuj B se svázanými omezeními této kauzální vazby;</li><li>pro kazdou hrozbu v〈ai p→ aj 〉nebo kvůli ai</li><li>zjemneni = množina možností odstraňující tuto hrozbu</li><li>nedeterministicky vyber p ∈ zjemnění</li><li>přidej p do <code>&lt;</code> nebo do B;</li><li>return PoP(P, agenda)</li></ul><h1 id=srovnani-planovani-se-stavyplany>Srovnani planovani se stavy/plany</h1><p>Díky doménově specifickým heuristikám je dnes plánování se stavy výrazně rychlejší.</p><p>Ale, plánování v prostoru plánů:</p><ul><li>vytváří flexibilnější plány díky částečnému uspořádání</li><li>umožňuje další rozšíření, např. přidání času a zdrojů</li></ul><table><thead><tr><th></th><th>Plánování se stavy</th><th>Plánování s plány</th></tr></thead><tbody><tr><td>prohled. prostor</td><td>konečný</td><td>nekonečný</td></tr><tr><td>uzly</td><td>jednoduche (stavy světa)</td><td>komplikovanější (částečné plány)</td></tr><tr><td>stavy světa</td><td>explicitní</td><td>nejsou</td></tr><tr><td>částečný plán</td><td>uspořádání a volba akcí se dělá najednou</td><td>volba akcí a jejich pořadí oddělené</td></tr><tr><td>struktura plánu</td><td>lineární bez vazeb</td><td>kauzální vazby</td></tr></tbody></table><h1 id=neurčitost-bayesovské-sítě>Neurčitost: Bayesovské sítě</h1><p>Podmíněná pravděpodobnost: P(x|y) = P(x ^ y)/P(y)</p><p>Podmíněnou pravděpodobnost často zapisujeme v podobě součinového pravidla:
<code>P(x∧y) = P(x|y)×P(y) P(X,Y ) = P(X|Y ) ×P(Y)</code></p><p>(Úplná) nezávislost: náhodné proměnné jsou na sobě nezávislé:</p><p>P(X|Y) = P(X) nebo P(Y|X) = P(Y) nebo P(X,Y) = P(X)P(Y)</p><p>Pravděpodobnosti elementárních jevů můžeme popsat tabulkou tzv. úplnou sdruženou distribucí</p><p>Chceme-li znát pravděpodobnost nějakého tvrzení, sečteme pravděpodobnosti všech „světů”, kde tvrzení platí (marginalizace)</p><p>\( P(Y) = \sum_{z \in Z} P(Y, z) \)</p><h2 id=diagnostická-vs-kauzální-vazba>Diagnostická vs. kauzální vazba</h2><p>Odhalení zdrojů dle symptomů, tj. diagnostická vazba
Z analýzy předchozích nemocí, spíš však máme k dispozici</p><ul><li>pravděpodobnost nemoci P(nemoc)</li><li>pravděpodobnost symptomu P(symptom)</li><li>kauzální vztah nemocí a symptomu P(symptomy|nemoc)</li></ul><h1 id=bayesovská-síť-bs>Bayesovská síť (BS)</h1><ul><li>Zachycuje závislosti mezi náhodnými proměnnými</li><li>Orientovaný acyklický graf (DAG)</li><li>uzel odpovídá náhodné proměnné</li><li>předchůdci uzlu v grafu se nazývají rodiče</li><li>každý uzel má přiřazenu tabulku podmíněné pravděpodobnostní distribuce P(X| Parents(X))</li></ul><h2 id=modelová-situace>Modelová situace</h2><ul><li>Máme v domě zabudovaný alarm, který se spustí při vloupání ale někdy také při zemětřesení</li><li>Sousedi Mary a John slíbili, že vždy, když alarm uslyší, tak nám zavolají</li><li>Zajímá nás pravděpodobnost vloupání, pokud John i Mary volají</li><li>Náhodné boolovské proměnné reprezentují možné události</li><li>Pravděpodobnostní tabulky reprezentují vztah podmíněné</li></ul><p>Bayesovská síť kompaktním způsobem reprezentuje úplnou sdruženou distribuci
(popisuje pravděpodobnost všech elementárních jevů)</p><p>P(x1,&mldr;,xn) = ∏_i P(xi |parents(Xi))</p><p>Zpětně lze ukázat, že tabulky P(X|Parents(X)) jsou podmíněné
pravděpodobnosti podle výše uvedené sdružené distribuce</p><p>Protože úplnou sdruženou distribuci lze použít pro odpověď na libovolnou
otázku v dané doméně, lze stejnou dopověď získat z Bayesovské sítě
(marginalizací)</p><h2 id=jak-konstruovat-baysovské-sítě>Jak konstruovat Baysovské sítě?</h2><p>Rozepíšeme P(x1,&mldr;,xn) pomocí tzv. řetězcového pravidla</p><h2 id=uzly>Uzly</h2><ul><li>funguje libovolné uspořádání, ale pro různá uspořádání dostaneme různě kompaktní site</li><li>doporučené uspořádání je takové, kdy příčiny předcházejí efekty</li></ul><h2 id=hrany>Hrany</h2><p>bereme proměnné Xi v daném pořadí od 1 do n</p><ul><li>v množině {X1,&mldr;,Xi−1} vybereme nejmenší množinu rodičů Xi tak, že platí P(Xi |Parents(Xi )) = P(Xi |Xi−1,&mldr;X1)</li><li>z rodičů vedeme hranu do Xi</li><li>vypočteme podmíněné pravděpodobnostní tabulky P(Xi |Parents(Xi ))</li></ul><h2 id=vlastnosti-2>Vlastnosti</h2><ul><li>síť je z principu konstrukce acyklická</li><li>síť neobsahuje redundantní informaci a tudíž je vždy konzistentní (splňuje axiomy pravděpodobnosti)</li></ul><p>Bayesovská síť může být mnohem kompaktnější než úplná sdružená distribuce, pokud je síť řídká (je lokálně strukturovaná)</p><ul><li>náhodná proměnná často závisí jen na omezeném počtu jiných proměnných</li><li>nechť je takových proměnných k a celkem máme n proměnných, pak potřebujeme prostor</li><li>n * 2^k pro Bayesovskou síť</li><li>2^n pro uplnou sdruženou distribuci</li><li>můžeme ignorovat „slabé vazby”, čímž budeme mít menší přesnost reprezentace, ale reprezentace bude kompaknější</li><li>samozřejmě kompaktnost sítě hodně závisí na vhodném uspořádání proměnných</li></ul><h2 id=odvozování-v-bayesovských-sítí-pomocí-enumerace>Odvozování v Bayesovských sítí pomocí enumerace</h2><ul><li>Připomeňme, k čemu mají Bayesovské sítě sloužit zjistit pravděpodobnostní distribuce náhodných proměnných X v dotazu za předpokladu znalosti hodnot e proměnných z pozorování</li><li>Hodnotu P(X,e,y) zjistíme z Bayesovské sítě P(x1,&mldr;,xn) = ∏_i P(xi |parents(Xi ))</li></ul><h2 id=eliminace-proměnných>Eliminace proměnných</h2><ul><li>Enumerační metoda zbytečně opakuje některé výpočty</li><li>Stačí si výsledek zapamatovat a následně použít</li><li>f_i spočítáme jednou a uschováme pro budoucí použití dynamické programování</li><li>Činitelé fi jsou matice (tabulky) pro dané proměnné</li><li>Vyhodnocení provedeme zprava doleva (viz příklad dále)</li><li>násobení činitelů je násobení po prvcích (ne násobení matic)</li><li>vysčítáním činitelů eliminujeme příslušnou proměnnou</li><li>na závěr provedeme normalizaci</li><li>tj. bottom-up přístup pro předchozí graf u odvozování enumerací</li></ul><h2 id=složitost-problému>Složitost problému</h2><p>Eliminace proměnných urychluje odvozování, ale jak moc?</p><ul><li>Pokud je Bayesovská síť poly-strom (mezi každými dvěma vrcholy vede maximálně jedna neorientovaná cesta), potom je časová a prostorová složitost odvozování lineární vzhledem k velikosti sítě (tj. velikosti tabulek).</li><li>Pro více-propojené sítě je to horší</li></ul><h1 id=vzorkovací-metody>Vzorkovací metody</h1><ul><li>Exaktní odvozování je výpočetně náročné, můžeme ale použít aproximační techniky založené na metodě Monte Carlo</li><li>Monte Carlo algoritmy slouží pro odhad hodnot, které je těžké spočítat exaktně</li><li>vygeneruje se množství vzorků(ohodnocení náhodných proměnných)</li><li>hledaná hodnota se zjistí statisticky</li><li>více vzorků = větší přesnost</li><li>Pro Bayesovské sítě ukážeme přístupy</li><li>příme vzorkování</li><li>vzorkování se zamítáním</li><li>vzorkování s vážením věrohodností</li></ul><h1 id=přímé-vzorkování>Přímé vzorkování</h1><ul><li>Vzorkem pro nás bude ohodnocení náhodných proměnných</li><li>Vzorek je potřeba generovat tak, aby „odpovídal” tabulkám v Bayesovské síti</li><li>uzly (proměnné) bereme v topologickém uspořádání</li><li>ohodnocení rodičů nám dá pravděpodobnostní distribuci hodnot aktuální náhodné proměnné</li><li>náhodně vybereme hodnotu podle této distribuce</li><li>Nechť N je počet vzorků a N(x1,&mldr;,xn) vyjadřuje počet výskytů jevu x1,&mldr;,xn, potom P(x1,&mldr;,xn) = lim_{N→∞}(N(x1,&mldr;,xn)/N)</li></ul><h1 id=vzorkování-se-zamítáním>Vzorkování se zamítáním</h1><ul><li>Nás ale zajímá P(X|e)</li><li>Ze vzorků, které vygenerujeme, vezmeme jen ty, které jsou kompatibilní s e (ostatní zamítneme)</li><li>Hlavní nevýhoda metody je zamítání příliš mnoha vzorků!</li></ul><h1 id=vážení-věrohodností-weighted-sampling-ws>Vážení věrohodností (Weighted Sampling, WS)</h1><ul><li>Místo zamítání vzorků je efektivnější: generovat pouze vzorky vyhovující pozorování e</li><li>Zafixujeme hodnoty z pozorování e a vzorkujeme pouze ostatní proměnné</li></ul><h1 id=čas-a-neurčitost>Čas a neurčitost</h1><ul><li>Dynamiku světa budeme modelovat sérií časových řezů</li><li>t je označení časového řezu</li><li>uvažujeme tedy diskrétní čas se stejnýmí časovými kroky</li><li>Každý řez/stav bude popsán (stejnou) množinou náhodných proměnných, které se dělí na</li><li>nepozorovatelné náhodné proměnné X_t</li><li>pozorované náhodné proměnné E_t</li><li>konkrétní pozorovanou množinu hodnot označíme e_t</li></ul><p>X_{t1:t2} označujeme množinu proměnných od Xt1 po Xt2</p><h2 id=modelová-situace-1>Modelová situace</h2><ul><li>Uvažujme agenta pracujícího na tajné podzemní základně, ze které nikdy nevychází</li><li>Zajímá ho, zda venku prší - náhodná nepozorovatelná proměnná R_t</li><li>Jediné pozorování, které má k dispozici, říká, zda ráno ředitel přišel s deštníkem nebo bez deštníku &ndash; náhodná pozorovaná proměnná Ut</li></ul><h2 id=přechodový-model>Přechodový model</h2><ul><li>Přechodový model popisuje, jak je stav ovlivněn předchozími stavy Přesněji popisuje pravděpodobnostní distribuci P(Xt|X0:t−1)</li></ul><ol><li>problem: s rostoucím t neomezeně roste množina X0:t−1</li></ol><ul><li>použijeme Markovský předpoklad: současný stav závisí pouze na pevně daném konečném počtu předchozích stavů – hovoříme potom o obecných Markovských řetězcích/procesech</li><li>např. současný stav závisí pouze na předchozím stavu Markovský proces prvního řádu P(Xt |X0:t−1) = P(Xt |Xt−1)</li></ul><ol start=2><li>problém: pořád máme nekonečně mnoho různých přechodů</li></ol><ul><li>použijeme předpoklad stacionárního procesu, tj. stav se vždy mění podle stejných pevně daných pravidel</li><li>distribuce P(Xt |Xt−1) je stejná pro všechny časy t</li></ul><h1 id=senzorický-model>Senzorický model</h1><ul><li>Senzorický model popisuje, na čem závisí pozorované náhodné proměnné E_t</li><li>Ty mohou záviset i na proměnných z předchozích stavů, ale uděláme Markovský senzorický předpoklad – pozorované proměnné závisí pouze na nepozorovatelných proměnných Xt ze stejného stavu</li><li>P(Et|X0:t,E1:t−1) = P(Et|Xt)</li></ul><h1 id=bayesovské-sítě-pro-přechodový-a-senzorický-model>Bayesovské sítě pro přechodový a senzorický model</h1><p>Přechodový a senzorický model můžeme popsat Bayesovskou sítí</p><h1 id=zpřesnění-modelu>Zpřesnění modelu</h1><p>Markovský proces prvního řádu předpokládá, že stavové proměnné obsahují veškerou informaci pro charakteristiku pravděpodobnostní distribuce dalšího stavu</p><p>Co když je tento předpoklad nepřesný?</p><ul><li>můžeme zvýšit řád Markovského procesu</li><li>můžeme rozšířit množinu stavových proměnných</li></ul><h1 id=řešené-úlohy>Řešené úlohy</h1><p>Odhad stavu (filtrace): cílem je zjištění pravděpodobnosti aktuálního stavu na základě dosavadních pozorování &ndash; P(X_t|e_1:t)</p><p>Predikce: cílem je zjištění pravděpodobnosti budoucího stavu na základě dosavadních pozorování: P(Xt+k|e1:t) pro k > 0</p><p>Vyhlazování: cílem je zjištění pravděpodobnosti minulého stavu na základě dosavadních pozorování: P(X_k|e_1:t) pro <code>k, kde 0 ≤k &lt; t</code></p><p>Nejpravděpodobnější průchod: na základě posloupnosti pozorování chceme zjistit nejpravděpodobnější posloupnost stavů, která tato pozorování generuje: argma_x_x1:t P(x_1:t|e_1:t)</p><h1 id=odhad-stavu-filtrace>Odhad stavu (filtrace)</h1><p>Úkolem je zjistit pravděpodobnost aktuálního stavu na základě dosavadních pozorování: P(Xt|e1:t)
Dobrý filtrační algoritmus odhaduje aktuální stav z odhadu předchozího stavu a aktuálního pozorování (rekurzivní odhad)</p><p>TODO: rovnice</p><h1 id=predikce>Predikce</h1><p>Úkolem je zjistit pravděpodobnost budoucího stavu na základě dosavadních pozorování. Jedná se v podstatě o filtraci bez přidávání dalších pozorování (rozšíření jednokrokové predikce z odvození filtrace)</p><p>Po určité době (mixing time) konverguje předpovězená distribuce ke stacionární distribuci a nadále zůstane stejná</p><h1 id=vyhlazování>Vyhlazování</h1><p>Úkolem je zjistit pravděpodobnost minulého stavu na základě dosavadních pozorování.
Opět použijeme rekurzivní předávání zpráv, tentokrát ve dvou směrech
Můžeme tedy použít techniku zpětné propagace zprávy</p><h1 id=užitek-a-rozhodování>Užitek a rozhodování</h1><h2 id=teorie-uzitku>Teorie uzitku</h2><p>(Agentovy) preference lze zaznamenat funkcí užitku U(s), která mapuje stavy s na reálné číslo</p><p>Očekávaný užitek (expected utility) potom spočteme jako průměrný užitek přes všechny možné stavy vážené pravděpodobností výsledků</p><p>Racionální agent potom volí akci maximalizující očekávaný užitek MEU</p><p>MEU formalizuje racionalitu, ale jak budeme celý postup operačně realizovat?</p><ul><li>Cíl: hledáme funkci užitku popisující preference</li><li>Agentovy preference se často vyjadřují relativním porovnáním</li><li>A > B: agent preferuje A před B</li><li><code>A &lt; B</code>: agent preferuje B před A</li><li>A ∼ B: agent mezi A a B nemá žádnou preferenci (nerozlišuje A a B)</li><li>Co je A nebo B?</li><li>mohou to být stavy světa, ale pro neurčité výstupy se používají loterie</li><li>loterie popisuje možné výstupy S1,&mldr;,Sn, které se vyskytují s danými pravděpodobnostmi p1,&mldr;,pn</li><li>Příklad loterie (nabídka jídla v letadle): Chcete kuře nebo těstoviny?</li><li>[0.8, dobré kuře; 0.2 připečené kuře]</li><li>[0.7, dobré těstoviny; 0.3, rozvařené těstoviny]</li></ul><h2 id=funkce-uzitku>Funkce uzitku</h2><ul><li><p>Existuje funkce užitku vracející pro danou loterii reálné číslo tak, že</p></li><li><p><code>U(A) &lt; U(B) ⇔A &lt; B</code></p></li><li><p><code>U(A) = U(B) ⇔A ∼B</code></p></li><li><p>Očekáváný užitek loterie lze spočítat:</p></li><li><p>U([p1,S1; &mldr;,pn ,Sn ]) = ∑_i pi U(Si )</p></li><li><p>Racionální agent ani nemusí svoji funkci užitku znát, ale pozorováním jeho preferencí ji lze zrekonstruovat</p></li><li><p>Jak zjistit funkci užitku konkrétního agenta (preference elicitation)?</p></li><li><p>budeme hledat normalizovanou funkci užitku</p></li><li><p>uvažujme nejlepší možný stav Smax a dejme mu užitek 1: U(Smax) = 1</p></li><li><p>podobně pro nejhorší možný stav Smin a dejme užitek 0: U(Smin) = 0</p></li><li><p>nyní se pro libovolný stav S ptejme agenta na porovnání S a standardní loterie [p,Smax; 1 −p,Smin]</p></li><li><p>podle výsledku upravíme pravděpodobnost p a ptáme se znova, dokud agent vztah A a standardní loterie nepovažuje za nerozlišitelný</p></li><li><p>získané p je užitkem S: U(S) = p</p></li><li><p>V praxi se často vyskytuje více atributů užitku, např. cena, nebezpečnost, užitečnost – víceatributová funkce užitku</p></li><li><p>Budeme uvažovat, že každý atribut má definované preferované pořadí hodnot, vyšší hodnoty odpovídají lepšímu řešení</p></li><li><p>Jak definovat preference pro více atributů dohromady?</p></li><li><p>přímo bez kombinace hodnot atributů – dominance</p></li><li><p>pokud je ve všech atributech řešení A horší než řešení B, potom B je lepší i celkově – striktní dominance</p></li><li><p>lze použít i pro nejisté hodnoty atributů</p></li><li><p>kombinací hodnot atributů do jedné hodnoty</p></li></ul><h1 id=rozhodovací-sítě>Rozhodovací sítě</h1><p>Jak obecně popsat mechanismus rozhodování?
Rozhodovací síť (influenční diagram) popisuje vztahy mezi vstupy (současný stav), rozhodnutími (budoucí stav) a užitkem (budoucího stavu)</p><p>Náhodné uzly (ovál)</p><ul><li>reprezentují náhodné proměnné stejně jako v Bayesovských sítích
Rozhodovací uzly (obdélníky)</li><li>popisují rozhodnutí (výběr akce), které může agent udělat (zatím uvažujeme jednoho agenta)
Uzly užitku (kosočtverce)</li><li>popisují funkci užitku</li></ul><h2 id=rozhodovací-sítě-vyhodnocovací-algoritmus>Rozhodovací sítě: vyhodnocovací algoritmus</h2><p>Akce jsou vybrány na základě vyzkoušení všech možných hodnot rozhodovacího uzlu</p><ol><li>nastavíme hodnoty pozorovaných proměnných</li><li>pro každou možnou hodnotu rozhodovacího uzlu</li><li></li></ol><ul><li>nastavíme rozhodovací uzel na danou hodnotu</li><li>použitím pravděpodobnostní inference vypočteme pravděpodobnosti rodičů uzlu užitku</li><li>vypočteme užitek pomocí funkce užitku</li></ul><ol start=4><li>vybereme akci s největším užitkem</li></ol><p>Pro případy, kde je více uzlů užitku používáme při výběru akce techniky pro víceatributové funkce užitku</p><p>Přímé rozšíření algoritmu pro Bayesovské sítě:</p><ul><li>při rozhodování agenta vybíráme akci s největším užitkem</li></ul><p>Zajímavější problém až při vykonávání posloupnosti rozhodnutí</p><h2 id=rozhodovací-sítě-konstrukce-a-příklad>Rozhodovací sítě: konstrukce a příklad</h2><ul><li>Vytvoření kauzálního modelu</li><li>určení symptomů, nemocí, léčby a vztahů mezi nimi (dom.experti, literatura)</li><li>Zjednodušení kvalitativního modelu</li><li>pokud nám jde o léčbu, můžeme odstranit uzly, které s nimi nesouvisí</li><li>některé uzly lze spojit (léčba Treatment a její načasování Timing)</li><li>Přiřazení pravděpodobností – z kauzálních vazeb, diagnostické vazby z BS:</li><li>vyplnění pravděpodobnostních tabulek jako v Bayesovské síti</li><li>Navržení funkce užitku</li><li>můžeme enumerovat možné výstupy</li><li>Verifikace a doladění modelu</li><li>výsledky se porovnají se zlatým standardem, např. skupinou lékařů</li><li>Analýza citlivosti</li><li>kontrola, zda výsledky systému nejsou citlivé na drobné změny vstupu</li></ul><h1 id=shrnuti>Shrnuti</h1><ul><li>Teorie pravděpodobnosti nám umožní kvantifikovat, jak máme danému tvrzení věřit na základě pozorování</li><li>Bayesovské sítě a odvozování pomocí nich &ndash; staticky v daném čase</li><li>Pravděpodobnostní uvažování o čase &ndash; reprezentace přechodů s pravděpodobností: Markovský proces, zjištění pravděpodobnosti stavu vzhledem k probíhajícímu času</li><li>Teorie užitku pro ohodnocení rozhodnutí</li><li>Teorie rozhodování</li><li>pro jedno rozhodnutí (statický případ)</li><li>pro posloupnost rozhodnutí</li></ul><h1 id=sekvenční-rozhodovací-problémy>Sekvenční rozhodovací problémy</h1><ul><li><p>Cílem je tvorba racionálních agentů maximalizujících očekávanou míru užitku</p></li><li><p>Teorie pravděpodobnosti říká, čemu máme věřit na základě pozorování</p></li><li><p>Teorie užitku (utility theory) popisuje, co chceme a jak máme ohodnotit rozhodnutí</p></li><li><p>Teorie rozhodování (decision theory) spojuje obě teorie dohromady a popisuje, jak bychom měli vybrat akci s největším očekávaným užitkem</p></li><li><p>Doposud jedno rozhodnutí → nyní posloupnost rozhodnutí</p></li><li><p>užitek bude záviset na posloupnosti rozhodnutí</p></li><li><p>Uvažujme agenta pohybujícího se v prostředí o rozměrech 3 × 4</p></li><li><p>Prostředí je plně pozorovatelné (agent vždy ví, kde se nachází)</p></li><li><p>Agent se chce dostat do stavu +1 a vyhnout se stavu -1</p></li><li><p>Agent může provést akce Up, Down, Left, Right</p></li><li><p>množinu akcí pro stav s značíme A(s)</p></li><li><p>výsledek akce je ale nejistý</p></li><li><p>s pravděpodobností 0.8 půjde správným směrem</p></li><li><p>s pravděpodobností 0.1 půjde kolmo k požadovanému směru (resp. stojí na místě, pokud narazí na zeď)</p></li><li><p>pravděpodobnost [Up, Up, Right, Right, Right]: 0.8^5</p></li></ul><h1 id=markovský-rozhodovací-proces-mdp>Markovský rozhodovací proces (MDP)</h1><ul><li>Pro popis přechodů (aplikace akce) použijeme pravděpodobnostní distribuci P(s′|s,a) – pravděpodobnost přechodu z s do s′ akcí a</li><li>opět uvažujeme Markovský předpoklad (pravděpodobnost přechodu nezávisí na předchozích navštívených stavech)</li><li>Užitek tentokrát závisí na prošlých stavech</li><li>každý stav má přiřazeno ocenění (reward) R(s)</li><li>funkce užitku bude (zatím) součet ocenění navštívených stavů</li><li>Markovský rozhodovací proces (Markov Decision Process MDP)</li><li>sekvenční rozhodovací problém v plně pozorovatelném stochastickém prostředí s Markovským přechodovým modelem a aditivní funkcí užitku</li><li>tvořen množinou stavů s počátečním stavem s0</li><li>množinou akcí v každém stavu A(s)</li><li>přechodovým modelem P(s′|s,a)</li><li>oceněním R(s)</li></ul><h2 id=řešení-mdp>Řešení MDP</h2><ul><li>Ve stochastickém prostředí nemůžeme pracovat s pevným pořadím akcí (plánem)</li><li>agent se může vydat jinam, než bylo naplánováno</li><li>Protože předem nevíme, kam akce agenta zavede potřebujeme v každém stavu vědět, co dělat (kam jít)</li><li>Řešením MDP je strategie (policy) π(S), což je funkce určující pro každý stav doporučenou akci</li><li>hledáme strategii s největším očekávaným užitkem = optimální strategie</li></ul><h2 id=optimální-strategie>Optimální strategie</h2><p>Optimální strategie maximalizuje očekávaný užitek</p><h2 id=užitek-v-čase-horizont>Užitek v čase: horizont</h2><p>Jak obecně definovat funkci užitku pro posloupnost stavů?</p><ul><li>je to podobné jako pro víceatributové funkce užitku U([s0,s1,&mldr;,sn]) (stavy jsou atributy), ale jaky mame horizont?</li></ul><h3 id=konečný-horizont1>Konečný horizont1</h3><ul><li>máme daný pevný termín N a po něm už na ničem nezáleží</li><li>optimální strategie záleží na termínu (není stacionární)</li></ul><h3 id=nekonečný-horizont1>Nekonečný horizont1</h3><ul><li>to neznamená nutně nekonečné posloupnosti stavů, pouze zde není žádný deadline</li><li>není důvod se ve stejném stavu chovat v různé časy různě</li><li>optimální strategie je stacionární</li></ul><h2 id=užitek-v-čase-definice-funkce>Užitek v čase: definice funkce</h2><ul><li>Funkce užitku se chová jako víceatributová funkce užitku U([s0,s1,&mldr;,sn])</li><li>Pro získání jednoduchého vztahu pro výpočet funkce užitku uvažujme stacionární preference</li><li>V případě stacionárních preferencí jsou dva způsoby, jak rozumně definovat funkci užitku</li><li>aditivní funkce užitku: R(s0) + R(s1) + &mldr;</li><li>kumulovaná (discounted) funkce užitku: R(s0) + γR(s1) + γR(s2) &mldr;</li><li>faktor slevy γ ∈(0,1) &ndash; preference mezi aktuálním a budoucím oceněním</li></ul><h2 id=užitek-v-čase-vlastnosti>Užitek v čase: vlastnosti</h2><ul><li>Budeme používat kumulovanou funkci užitku</li><li>pro světy bez cílového stavu a nekonečný horizont by aditivní funkce užitku byla problémová</li><li>užitek v kumulované funkci užitku je konečný (uvažujeme omezené ocenění s maximem Rmax)</li><li>pokud má prostředí cílový stav, do kterého se agent garantovaně může dostat, nebudeme potřebovat pracovat s nekonečnými posloupnostmi</li><li>řádná (proper) strategie – garantuje dosažení cílového stavu</li><li>u nekonečné posloupnosti lze porovnat průměrné ocenění</li><li>lepší je zůstat ve stavu s oceněním 0.1 než ve stavu s oceněním 0.01</li></ul><h1 id=bellmanova-rovnice>Bellmanova rovnice</h1><p>TODO: vzoroec
TODO: iterace hodnot</p><h1 id=robotický-hardware-senzory>Robotický hardware: senzory</h1><ul><li>pasivní senzory slouží k pozorování prostředí, kdy zachycují signály generovanými dalšími zdroji v prostředí</li><li>aktivní senzory vysílají energii do prostředí (např. sonar) založeny na tom, že je energie reflektována senzoru zpět</li><li>poskytují více informací než pasivní senzory</li><li>náročnější na energii než pasivní senzory</li><li>hrozí nebezpečí interfence při použití více aktivních senzorů zároveň</li></ul><p>Senzory dělíme v závislosti na tom, zda určeny pro vnímání:</p><ul><li>prostředí, tj. dálkoměry pro měření vzdálenosti od blízkých objektů</li><li>robotova umístění, tj. lokační senzory</li><li>časté řešení lokalizačního problému: Global Positioning System (GPS)</li><li>robotovy vnitřní konfigurace, např.</li><li>pro měření přesné konfigurace robotických kloubů, motorů</li><li>gyroskopy – pro udržení referenčního směru</li></ul><p>Efektory umožňují robotovi pohyb a změnu tvaru těla
Aktuátor/akční člen (actuator) zahajuje pohyb efektoru</p><ul><li>především elektrický akční člen</li><li>také hydraulický, penumatický akční člen
Stupeň volnosti (degree of freedom DOF)</li><li>umožňuje pochopit návrh efektoru</li><li>jeden DOF pro každý nezávislý směr, ve kterém se robot nebo jeden z jeho efektorů může pohybovat</li></ul><p>Kinematický stav: určen DOFs
Dynamický stav: zahrnuje DOF kinematického stavu + dimenze pro rychlost změny kinematické dimenze
Počet DOFs nemusí být stejný jako počet ovládaných prvků (mobilní roboti)</p><h2 id=software-problémy-v-robotice>Software: problémy v robotice</h2><p>Robot v izolovaném známém prostředí</p><ul><li>agent jako Markovský rozhodovací proces MDP
Problémy v robotice</li><li>nedeterministické, částečně pozorovatelné, multiagentní</li><li>agent jako částečně pozorovatelný Markovův rozhodovací proces</li></ul><p>Hierarchie problémů v robotice</p><ul><li>plánování úloh (task planning): určení plánu nebo strategie</li><li>plánování pohybu (motion planning) nalezení cesty pro robota z jednoho budu do druhého pro splnění každého podcíle</li><li>řízení (control) k zajištění plánovaného pohybu akčnímí členy</li></ul><p>učení preferencí: vyhodnocení cílů koncových uživatelů a predikce chování lidí v prostředí robota</p><h1 id=dynamická-bayesovská-síť-dbn>Dynamická Bayesovská síť (DBN)</h1><p>Reprezentuje temporální pravděpodobnostní model. Skládá se z opakujících se vrstev proměnných. Dle Markovských předpokladů má každá proměnná rodiče buď ve stejné nebo předchozí vrstvě</p><p>staci popsat:</p><ul><li>prvni vrstvu</li><li>apriorni distribuci</li><li>prechodovy model</li><li>senzoricky model</li></ul><h1 id=plánování-pohybu-robota>Plánování pohybu robota</h1><p>Pohyb z bodu do bodu - přesun robota do cíle
Koordinovaný pohyb - robot se přesunuje v kontaktu s předmětem
Konfigurační prostor - používá se pro reprezentaci plánovacího problému, je to prostor stavů robota definovaný jeho umístěním, orientací a úhly kloubů, vhodnější reprezentace než původní 3D prostor.
Plánování cesty - problém nalezení cesty z jedné konfigurace do druhé v konfiguračním prostoru, na rozdíl od klasického hledání cesty v diskrétním prostoru se pohybuje ve spojitém prostoru.</p><h1 id=reprezentace-konfiguračního-prostoru>Reprezentace konfiguračního prostoru</h1><p>Souřadnice určují reprezentaci pracovního prostoru – reálného prostoru, kdy jsou souřadnice robota zadány stejným souřadným systémem jako objekty, kterými manipulujeme. Reprezentace
vhodná pro kontrolu kolizí zejména robota a objektů zadaných jednoduchými polygonálními modely. Problémy: všechny souřadnice pracovního prostoru nejsou dosažitelné, generování cest,
které dodržují tato omezení je velmi náročné.</p><h1 id=reprezentace-konfiguračního-prostoru-1>Reprezentace konfiguračního prostoru</h1><p>Reprezentace pomocí robotových kloubů.</p><p>Plánování cesty: spojíme aktuální pozici a cíl rovnou čarou a robot se po ní pohybuje konstantní rychlostí, dokud nedorazí do cíle
Problém: úloha robota je většinou zadána v pracovním, a ne v konfiguračním prostoru.
Kinematika: transformace souřadnic z konfiguračního prostoru do pracovního prostoru je jednoduchá – lineární transformace pro otočné klouby
Inverzní kinematika: opačná transformace – obtížná, zřídka jedno řešení, např. pozice chapadla umožňují dvě konfigurace</p><h1 id=plánování-pohybu-postup-řešení>Plánování pohybu: postup řešení</h1><ol><li>Předzpracování / učící fáze / konstrukce grafu</li></ol><ul><li>vypočítání grafu – často označován jako cestovní mapa (roadmap)</li><li>graf viditelnosti</li><li>Voroného diagram</li><li>buňková dekompozice</li><li>potenční funkce</li></ul><ol start=2><li>Zpracování dotazu</li></ol><ul><li>spojení počáteční a cílové konfigurace s grafem</li><li>identifikace počáteční a cílové buňky</li><li>prohledávání grafu</li></ul><ol start=3><li>Inkrementální konstrukce grafu směrem k cíli</li></ol><ul><li>rychle prozkoumávající náhodný strom (RRT)</li></ul><p>Základní problém plánování pohybu: nalezení spojité posloupnosti konfigurací, která převede robota z iniciální konfigurace qI do cílové
konfigurace qG tak, že se žádná konfigurace po cestě nepřekrývá s překážkou.</p><h1 id=graf-viditelnosti-visibility-graph>graf viditelnosti (visibility graph)</h1><ul><li>Spojíme všechny páry vrcholů plus iniciální a cílové konfigurace</li><li>Eliminujeme hrany, které protínají překážky</li><li>Graf viditelnosti vždy zahrnuje nejkratší cestu konfiguračním prostorem</li></ul><p>Konstrukce grafu viditelnosti</p><ul><li>popsaný (naivní) postup pro n vrcholů O(n^3)</li><li>s pomocí rotačního stromu pro množinu segmentů O(n^2)</li></ul><h1 id=voroného-diagram>Voroného diagram</h1><ul><li>dělí prostor R2 na oblasti podle zadaných objektů, např. bodů x ∈M</li><li>každý bod x má přiřazenu Voroného oblast V (x)</li><li>pro každý bod y ∈V (x) je x nejbližší bod z M</li></ul><p>Cestovní mapa jako VD, který maximalizuje vzdálenost od překážek.</p><ul><li>Robot změní konfiguraci na bod ve VD - toto lze realizovat pohybem po rovné čáře v konfiguračním prostoru</li><li>Robot se pohybuje ve VD, dokud nedosáhne bod, který je nejbližší cílové konfiguraci</li><li>Robot opustí VD a přesune se do cíle - opět rovnou čarou v konfiguračním prostoru</li></ul><h1 id=graf-viditelnosti-vs-voroného-diagram>Graf viditelnosti vs. Voroného diagram</h1><p>Graf viditelnosti</p><ul><li>nejkratší cesta, ale blízko k překážkám nutno uvažovat bezpečnost cesty</li><li>komplikované ve vyšší dimenzi</li></ul><p>Voroného diagram</p><ul><li>maximalizuje vzdálenost od překážek, což poskytuje konzervativní cesty</li><li>malé změny překážek mohou vést k velkým změnám VD</li><li>komplikované ve vyšší dimenzi</li></ul><h1 id=buňková-dekompozice>Buňková dekompozice</h1><p>Dekompozice volného prostoru na konečný počet spojitých regionů nazývaných buňky. Plánování cesty redukováno na prohledávání v diskrétním grafovém prostoru. Základní grafová dekompozice: pravidelná mřížka – úroveň šedi buňky určuje hodnotu buňky = cenu nejkratší cesty do cíle. Hodnoty spočítáme deterministickou verzí algoritmu iterací hodnot nebo A* algoritmem.</p><p>Zpracování částečně obsazených buněk:</p><ul><li>neprocházet tyto buňky - neúplné: nemusí existovat cesta</li><li>procházet tyto buňky - nekorektní: může vrátit cestu, která neexistuje</li><li>zvětšít rozlišení mřížky - drahé: zejména ve vyšší dimenzi</li><li>adaptivní diskretizace - ztráta uniformní velikosti mřížky</li></ul><h1 id=vertikální-dekompozice-vertical-decomposition>Vertikální dekompozice (vertical decomposition)</h1><p>Exaktní buňková dekompozice (př. vertikální/lichoběžníková, triangulace):</p><h1 id=potenciální-pole>Potenciální pole</h1><p>Dodatečná cenová fce. Hodnota potenciálu pole narůstá ze vzdáleností od nejbližší překážky. Potenciál pole je pak využit jako dodatečná cenová fce při výpočtu nejkratší vzdálenosti</p><h1 id=pravděpodobnostní-cestovní-mapa--probabilistic-roadmap>Pravděpodobnostní cestovní mapa – probabilistic roadmap</h1><p>Diskrétní reprezentace spojitého konfiguračního prostoru generována náhodným vzorkováním konfigurací v Cfree, které spojíme do grafu</p><ul><li>vrcholy: přípustné konfigurace robota (milestones)</li><li>hrany: reprezentují platnou cestu (trajektorii) mezi konfiguracemi</li></ul><p>Nevyžaduje explicitní popis Cobs
Cesta (trajektorie) ze startu do cíle: grafové prohledávací algoritmy</p><h2 id=jeden-vs-více-dotazů>Jeden vs. více dotazů</h2><p>Více dotazů na pravděpodobnostní cestovní mapu</p><ul><li>generování jedné cestovní mapy, která je používána pro plánovací dotazy vícekrát</li></ul><p>Jeden dotaz na pravděpodobnostní cestovní mapu</p><ul><li>pro každý plánovací problém konstruována nová cestovní mapa charakteristická pro podprostor konfiguračního prostoru relevantní pro problém</li><li>rychle prozkoumávající náhodný strom (RRT)</li></ul><h2 id=strategie-pro-více-dotazů>Strategie pro více dotazů</h2><p>Vytvoření cestovní mapy (grafu), který reprezentuje prostředí</p><ul><li>Učící fáze</li><li>Vzorkování n bodů v C_free</li><li>Spojení náhodných konfigurací s použitím lokálního plánovače (lokální plánovač hledá lokální cesty, např. přímé)</li><li>Dotazovací fáze</li><li>Spojení počáteční a cílové konfigurace s PRM</li><li>Použití prohledávání grafu k nalezení cesty</li></ul><h2 id=vlastnosti-prm>Vlastnosti PRM</h2><p>Úplnost pro standardní PRM nediskutována
Většinou studována sPRM, která je</p><ul><li>pravděpodobnostně úplná a asymptoticky optimální</li><li>složitost konstrukce grafu (učící fáze) O(n2)</li><li>složitost i prostorova slozitost dotazu O(n2)</li></ul><h1 id=rychle-prozkoumávající-náhodný-strom--rapidly-exploring-random-tree-rrt>Rychle prozkoumávající náhodný strom – Rapidly exploring random tree (RRT)</h1><ul><li>Algoritmus pro jeden dotaz</li><li>Motivací je hledání cesty založené na řízení</li><li>Inkrementální konstrukce grafu (stromu) směrem k cílové oblasti</li></ul><h2 id=postup-tvorby-stromu>Postup tvorby stromu</h2><ul><li>Začni s počáteční konfigurací qinit , která je kořenem konstruovaného stromu</li><li>Generuj náhodnou konfiguraci qnew v Cfree</li><li>Nalezni nejbližší uzel qnear ke qnew ve stromě</li><li>Rozšiř qnear směrem ke qnew</li><li>Pokud není strom v dostatečné vzdálenosti od cílové konfigurace, běž na krok 2.</li></ul><h2 id=vlastnosti-rrt>Vlastnosti RRT</h2><ul><li>Rychle prozkoumává prostor</li><li>Umožňuje uvažování kinodynamických/dynamických omezeni</li><li>Umí nalézt trajektorie nebo posloupnosti přímou kontrolou příkazů robotových ovladačů</li><li>Test na detekci kolize obvykle jako black-box</li><li>Podobně jako PRM má RRT problémy s úzkými pasážemi</li><li>RRT nalezne proveditelnou cestu bez garance kvality</li><li>cesta může být relativně daleko od optimální cesty dané např. délkou cesty</li><li>Navrženo mnoho variant RRT</li></ul><h1 id=skeletonizace>Skeletonizace</h1><p>Alternativní přístup pro převedení plánování cesty na prohledávání v diskrétním grafovém prostoru. Robotův volný prostor je redukován na jednodimenzionální reprezentaci nazvanou
skeleton = Voroného diagram – množina všech bodů, které mají stejné vzdálenosti od dvou nebo více překážek. Plánování cesty redukováno na hledání nejkratší cesty ve Voroného diagramu.</p><h1 id=dynamický-stav>Dynamický stav</h1><p>Přechodový model pro dynamický stav zahrnuje účinek sil na rychlost změny. Nutné modely vyjádřené diferenciálními rovnicemi, které provážou kvantitu s odpovídající změnou v čase. Pokud
bychom uměli generovat takové plány, roboti by měli skvělý výkon. Dynamický stav má však více dimenzí než kinematický, plánovací algoritmy by byly použitelné pouze pro nejjednodušší roboty.
Robotické systémy v praxi se spoléhají na jednodušší kinematické plánovače cest.</p><h1 id=regulátor>Regulátor</h1><p>Kompenzuje limitace kinematických plánů, aby byla zachována cesta.</p><p>Referenční regulátor – snaží se robota udržet na naplánované cestě.
Proporční derivační regulátor – nejjednodušší regulátor, který zachovává striktní stabilitu v naší doméně
Integrační proporční derivační regulátor - umožňuje odstranit chybové chování PD regulátoru v některých případech. Chybové hlášení jako důsledek systematické vnější síly, která není součástí modelu.
Dlouhotrvající odchylky mezi referenčním a aktuálním stavem opraveny. Regulátor tak řeší systematické chyby na úkor zvýšeného nebezpečí oscilací.</p><h1 id=další-způsoby-řízení-pohybu>Další způsoby řízení pohybu</h1><p>Řízení pomocí potenciálu pole – podobně jako při plánování pohybu
Reaktivní řízení – můžeme specifikovat regulátor bez explicitního modelu prostředí,
nejprve si určíme vzor posunu končetin a pak už reaktivně reagujeme na daný stav
Zpětnovazební učení</p></div></article><hr><div class=post-info></div></main></div><footer class=footer></footer><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script></div><script type=text/javascript src=/bundle.min.77414ca1a0d130043c129098d97cecf433ce369d23de8eaa91f5111f432729db1257c49a33b38203d4be241ef53dafecd99a1d2c350b75316b55a0bb6a2e150b.js integrity="sha512-d0FMoaDRMAQ8EpCY2Xzs9DPONp0j3o6qkfURH0MnKdsSV8SaM7OCA9S+JB71Pa/s2ZodLDULdTFrVaC7ai4VCw=="></script></body></html>